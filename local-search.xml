<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS61B第三周总结</title>
    <link href="undefined2020/01/06/CS61B%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <url>2020/01/06/CS61B%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第三周总结笔记"><a href="#第三周总结笔记" class="headerlink" title="第三周总结笔记"></a>第三周总结笔记</h1><p>CS61B的第三周主要是关于Java的单元测试，双向链表这两个部分</p><h2 id="一，Java的单元测试与Junit"><a href="#一，Java的单元测试与Junit" class="headerlink" title="一，Java的单元测试与Junit"></a>一，Java的单元测试与Junit</h2><p>Junt的一些基本用法。没啥好说的。详细的内容之后才有。</p><h2 id="二，Java的接口，实现接口以及动态静态类型"><a href="#二，Java的接口，实现接口以及动态静态类型" class="headerlink" title="二，Java的接口，实现接口以及动态静态类型"></a>二，Java的接口，实现接口以及动态静态类型</h2><h3 id="（1）接口实现interface-implement和默认方法default关键字"><a href="#（1）接口实现interface-implement和默认方法default关键字" class="headerlink" title="（1）接口实现interface implement和默认方法default关键字"></a>（1）接口实现interface implement和默认方法default关键字</h3><p>简单来说就是接口原先不能有方法体，但是从Java8开始接口可以先实现一个默认的方法体。采用<code>default</code>关键字。</p><p><img src="https://raw.githubusercontent.com/StoicLD/Photos/master/Other/20200105201126.png" srcset="/img/loading.gif" alt=""></p><h3 id="（2）Static-Type和Dynamic-Type以及Dynamic-Method-Selection"><a href="#（2）Static-Type和Dynamic-Type以及Dynamic-Method-Selection" class="headerlink" title="（2）Static Type和Dynamic Type以及Dynamic Method Selection"></a>（2）Static Type和Dynamic Type以及Dynamic Method Selection</h3><p>如下所示的一个例子。可以看到最后</p><pre><code class="java">a.flatter(d);</code></pre><p>输出的是”u r cool animal”。这就涉及到所谓的<strong>Static Type</strong>和<strong>Dynamic Type</strong>以及<strong>Dynamic Method Selection</strong>。</p><p><img src="https://raw.githubusercontent.com/StoicLD/Photos/master/Other/20200105201402.png" srcset="/img/loading.gif" alt=""></p><p><strong>Static Type</strong>和<strong>Dynamic Type</strong>定义如下</p><p><img src="https://raw.githubusercontent.com/StoicLD/Photos/master/Other/20200105201759.png" srcset="/img/loading.gif" alt=""></p><p>声明的类型是<strong>Static Type</strong>，而实例化的时候的类型是<strong>Dynamic Type</strong></p><p>然后我们明确一下overriding重写和overload重载</p><p>overriding重写指的是子类或者接口的实现类对于签名一致（既参数与函数名一致）的父类函数或者接口函数的实现。</p><p>overload指的是函数名一致但是参数不同的另一种函数实现方式。</p><hr><p>最后我们再来看下<strong>Method Selection Algorithm</strong></p><p><img src="https://raw.githubusercontent.com/StoicLD/Photos/master/Other/20200105202006.png" srcset="/img/loading.gif" alt=""></p><p>以此为例：<br>解析a.flatter(d)<br>a的<strong>static type</strong>是Animal，<strong>dynamic type</strong>是Dog<br>d的<strong>static type</strong>是Dog，<strong>dynamic type</strong>是Dog</p><p>a.flatter(d); 在编译期，记录下a的<strong>static type</strong>的方法中可以处理d的<strong>static type</strong>类型参数的方法，此处就是Animal的flatter方法。（d继承自Animal，尽管d的static type和dynamic type都是Dog，但还是可以作为Animal类型的参数被接受）</p><p>因为Dog的flatter方法是<strong>重载</strong>了其父类Animal的flatter方法<br>而不是<strong>重写overriding</strong>，所以运行时没有改变Animal的flatter<br>方法改为Dog版本的（因为不是重写！！！）<br>所以最后还是采用了Animal版本的flatter方法</p><p><img src="https://raw.githubusercontent.com/StoicLD/Photos/master/Other/20200105201402.png" srcset="/img/loading.gif" alt=""></p><h2 id="三，双端队列"><a href="#三，双端队列" class="headerlink" title="三，双端队列"></a>三，双端队列</h2><p>参见链表目录下的<a href="/Users/Ld19980608/OneDrive/Typora/CS61B/链表/Deque.md">Deque文章</a></p><h2 id="四，参考资料"><a href="#四，参考资料" class="headerlink" title="四，参考资料"></a>四，参考资料</h2><p>【1】<a href="https://joshhug.gitbooks.io/hug61b/content/chap2/chap25.html" target="_blank" rel="noopener">Josh Hug’s Book</a></p><p>【2】<a href="https://docs.google.com/presentation/d/1LGQeMHb8-HFKdvJi5nGKRIPZt4on18fZe-cIyTJv8_4/edit" target="_blank" rel="noopener">Alist Slides</a></p><p>【3】<a href="https://docs.google.com/presentation/d/1g2RwCFKvbv2x0lkFW9hwK1IcmNTHEqZloOLRgF4clhA/edit#slide=id.g3996ea012_0156" target="_blank" rel="noopener">Testing Slides</a></p><p>【4】<a href="https://docs.google.com/presentation/d/1b-Ue_mWWMI2CeHfaU_GO6PWhIpAr_SyZge9JQJQFpXc/edit#slide=id.g1c60d50676_54_6" target="_blank" rel="noopener">inheritance</a></p><p>【5】<a href="https://sp19.datastructur.es/materials/proj/proj1a/proj1a#1-linked-list-deque" target="_blank" rel="noopener">Project1A</a></p>]]></content>
    
    
    <categories>
      
      <category>CS61B</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>CS61B</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双端队列</title>
    <link href="undefined2020/01/06/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    <url>2020/01/06/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="双端队列的两种实现方式"><a href="#双端队列的两种实现方式" class="headerlink" title="双端队列的两种实现方式"></a>双端队列的两种实现方式</h1><h2 id="零，前言"><a href="#零，前言" class="headerlink" title="零，前言"></a>零，前言</h2><p>CS61B第三周的Project1A：</p><p>内容是实现Deque这种双向链表数据结构，底层的实现方式分别是基于内存不连续的<strong>链表</strong>和内存连续的<strong>数组</strong></p><p><a href="https://sp19.datastructur.es/materials/proj/proj1a/proj1a#1-linked-list-deque" target="_blank" rel="noopener">作业链接</a></p><h2 id="一，基于链表的Deque：LinkedListDeque"><a href="#一，基于链表的Deque：LinkedListDeque" class="headerlink" title="一，基于链表的Deque：LinkedListDeque"></a>一，基于链表的Deque：LinkedListDeque</h2><h3 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h3><ul><li><p><code>public void addFirst(T item)</code>: Adds an item of type <code>T</code> to the front of the deque.</p></li><li><p><code>public void addLast(T item)</code>: Adds an item of type <code>T</code> to the back of the deque.</p></li><li><p><code>public boolean isEmpty()</code>: Returns true if deque is empty, false otherwise.</p></li><li><p><code>public int size()</code>: Returns the number of items in the deque.</p></li><li><p><code>public void printDeque()</code>: Prints the items in the deque from first to last, separated by a space. Once all the items have been printed, print out a new line.</p></li><li><p><code>public T removeFirst()</code>: Removes and returns the item at the front of the deque. If no such item exists, returns null.</p></li><li><p><code>public T removeLast()</code>: Removes and returns the item at the back of the deque. If no such item exists, returns null.</p></li><li><p><code>public T get(int index)</code>: Gets the item at the given index, where 0 is the front, 1 is the next item, and so forth. If no such item exists, returns null. Must not alter the deque!</p></li><li><p><code>public LinkedListDeque()</code>: Creates an empty linked list deque.</p></li><li><p><code>public LinkedListDeque(LinkedListDeque other)</code>: Creates a deep copy of <code>other</code>. Creating a deep copy means that you create an entirely new <code>LinkedListDeque</code>, with the exact same items as <code>other</code>. However, they should be different objects, i.e. if you change <code>other</code>, the new <code>LinkedListDeque</code> you created should not change as well. (Edit 2/6/2018: A walkthrough that provides a solution for this copy constructor is available at <a href="https://www.youtube.com/watch?v=JNroRiEG7U4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=JNroRiEG7U4</a>)</p></li><li><p><code>public T getRecursive(int index)</code>: Same as get, but uses recursion.</p></li></ul><h3 id="思想和注意要点"><a href="#思想和注意要点" class="headerlink" title="思想和注意要点"></a>思想和注意要点</h3><p>第一种基于链表的实现，因为是双向链表，而且为了避免一些corner case，所以添加了一个<code>sentinelnote</code> ，就是一个哨兵节点或者叫做哑节点。这个节点自身不存有任何的信息，只有一个next和prev分别指向下一个节点（一般是头节点）和前一个节点（一般是尾节点）。如下图所示</p><p><img src="https://raw.githubusercontent.com/StoicLD/Photos/master/Other/20200105190807.png" srcset="/img/loading.gif" alt=""></p><p>总的来说实现起来没有多大的困难（当然我好久没写代码了，写了好久555</p><p>需要注意的是添加删除节点时候的一些关系，比方说下面这个向头部添加一个节点</p><pre><code class="java">    public void addFirst(T item)    {        Node rest = sentinelNode.next;        Node newFirstNode = new Node(sentinelNode, item, rest);        sentinelNode.next = newFirstNode;        if(rest != null) {            rest.prev = sentinelNode.next;        }        else {            //只有一个节点的时候，新创建的节点的下一个和上一个节点都是senti            newFirstNode.next = sentinelNode;            sentinelNode.prev = newFirstNode;        }        size++;    }</code></pre><p>事实上，如果<code>sentinelNode</code>一开始<code>size=0</code>的时候<code>prev</code>和<code>next</code>都指向自身，代码可以简化，不需要有<code>sentinelNode.next</code>判断为null的特殊情况。</p><pre><code class="java">    public void addFirst(T item) {        Node node = new Node(sentinel, item, sentinel.next);        sentinel.next.prev = node;        sentinel.next = node;        size += 1;    }</code></pre><h2 id="二，基于数组的Deque：ArrayDeque"><a href="#二，基于数组的Deque：ArrayDeque" class="headerlink" title="二，基于数组的Deque：ArrayDeque"></a>二，基于数组的Deque：ArrayDeque</h2><p>同样是实现双向链表，只是底层的数据结构是数组，这个难度我认为大一点。由于实现的函数与上面一样，都有在头部和尾部添加节点以及删除节点的行为。所以我们把整个数组看成是环状数组。靠两个下标<code>headIndex</code>和<code>tailIndex</code>来记录当前头部位置和尾部位置。</p><p><img src="https://raw.githubusercontent.com/StoicLD/Photos/master/Other/20200105192640.png" srcset="/img/loading.gif" alt=""></p><h3 id="头部和尾部指针-下标-索引"><a href="#头部和尾部指针-下标-索引" class="headerlink" title="头部和尾部指针/下标/索引"></a>头部和尾部指针/下标/索引</h3><p>一个难点是当往头部或者尾部插入节点时，<code>headIndex</code>和<code>tailIndex</code>应该怎么移动的问题。一开始我设想了很多种corner case，但实际上只要加一再对数组容量取余或者减一取余就可以了。其实只有两种情况，一种是head小于tail，另一种则是head大于tail。</p><p>比方说一开始只往尾部添加，不断地调用<code>addLast()</code>，那么就如下所示。head在tail左侧</p><p><img src="https://raw.githubusercontent.com/StoicLD/Photos/master/Other/20200105193921.png" srcset="/img/loading.gif" alt=""></p><p>但也有可能如下所示，先<code>addFirst</code>然后再<code>addLast</code></p><p><img src="https://raw.githubusercontent.com/StoicLD/Photos/master/Other/20200105194740.png" srcset="/img/loading.gif" alt=""></p><p>总之，只有这两种情况。如果我们把整个数组看成一个收尾连接的圆环（实际上我们实现的效果就是这样的），那么head的增长方向和tail的增长方向都是不变且相反的。如上图所示，head一直向“左”走，而tail一直向“右”走。只不过当他们各自抵达数组的真实头尾时会从另一边开始继续走。</p><p>因此代码如下（先不管扩容部分）</p><pre><code class="java">    public void addFirst(T item)    {        if(size + 1 &gt; capacity)        {            //扩容一倍            scale(FACTOR);        }        if (size != 0) {            headIndex = (headIndex + capacity - 1) % capacity;        }        items[headIndex] = item;        size++;    }</code></pre><pre><code class="java">    public void addLast(T item)    {        if(size + 1 &gt; capacity)        {            //扩容一倍            scale(FACTOR);        }        if(size != 0) {            tailIndex = (tailIndex + capacity + 1) % capacity;        }        //当tailIndex和headIndex重合时，就是0个元素        items[tailIndex] = item;        size++;    }</code></pre><h3 id="扩容和缩容"><a href="#扩容和缩容" class="headerlink" title="扩容和缩容"></a>扩容和缩容</h3><p>由于底层的数据结构是数组，因此我们一开始分配的空间是一定的。如果我们持续不断的添加元素，数组就势必要扩容。而删除元素到一定程度，为了节省空间则需要缩容。扩容感觉很自然，毕竟装不下了就要扩容，天经地义。那缩容的必要性呢？</p><p>考虑一种情况，先插入1万个元素，然后再删除9999个元素，只剩下一个元素。但是现在的数组却因为之前的扩容而占据了1万个元素的空间。</p><p>因此我们需要缩容，并且指定一个标准，比方说当前元素个数占据总容量的四分之一以下的时候，缩容一半。代码如下</p><pre><code class="java">    public void scale(int multiple)    {        if(multiple &lt; 1)            return;        T[] scaledItems = (T[])new Object[capacity * multiple];        //拷贝的时候应该分为两种情况        //（1）head在左侧，tail在右侧，这就是正常顺序        //（2）tail在左侧，head在右侧，这是一端超过末尾了        if(headIndex &lt; tailIndex) {            System.arraycopy(items, headIndex, scaledItems, 0, tailIndex - headIndex + 1);        }        else {            //复制从第headIndex元素到线型数组最后一个下标所在的元素            //复制从第0个下标对应元素到tailIndex（应该是headIndex - 1）的所有元素            System.arraycopy(items, headIndex, scaledItems, 0, capacity - headIndex);            System.arraycopy(items, 0, scaledItems, capacity - headIndex, tailIndex + 1);        }        items = scaledItems;        capacity *= multiple;        criticalValue = capacity / 4;       //只有在每次扩容和缩容时计算一次临界值，这样每次只要和临界值比大小就可以了        //重置头尾节点        headIndex = 0;        tailIndex = size - 1;    }</code></pre><pre><code class="java">public void descale(int shrink){    if(shrink &lt; 1)        return;    //缩容通常是2倍缩小    T[] scaledItems = (T[])new Object[capacity / shrink];    if(headIndex &lt; tailIndex) {        // 无论缩容还是扩容，都不会出现headIndex和tailIndex重合的情况（这两者只有size = 0时候才会重合）        System.arraycopy(items, headIndex, scaledItems, 0, tailIndex - headIndex + 1);    }    else {        System.arraycopy(items, headIndex, scaledItems, 0, capacity - headIndex);        System.arraycopy(items, 0, scaledItems, capacity - headIndex, tailIndex + 1);    }    items = scaledItems;    capacity /= shrink;    criticalValue = capacity / 4;       //只有在每次扩容和缩容时计算一次临界值，这样每次只要和临界值比大小就可以了    //重置头尾节点    headIndex = 0;    tailIndex = size - 1;}</code></pre><h2 id="三，总结"><a href="#三，总结" class="headerlink" title="三，总结"></a>三，总结</h2><p>这次Project算是重新让我温故了一下链表，以及好久没写过的Java（我甚至好久没写代码了。。。）。深感写代码的人还是需要熟能生巧，我大一的时候甚至都可能比现在写到更快更熟练。总之接下来就是一个字 “练”。</p><h2 id="四，参考资料与相关链接"><a href="#四，参考资料与相关链接" class="headerlink" title="四，参考资料与相关链接"></a>四，参考资料与相关链接</h2><p>【1】<a href="https://github.com/StoicLD/CS61B-Spring2019/blob/master/proj1a/LinkedListDeque.java" target="_blank" rel="noopener">实现代码</a></p><p>【2】<a href="https://docs.google.com/presentation/d/1LGQeMHb8-HFKdvJi5nGKRIPZt4on18fZe-cIyTJv8_4/edit#slide=id.g625dc7e36_00" target="_blank" rel="noopener">CS61B Lecture4 slides</a></p><p>【3】<a href="https://sp19.datastructur.es/materials/proj/proj1a/proj1a#1-linked-list-deque" target="_blank" rel="noopener">Project1A</a></p>]]></content>
    
    
    <categories>
      
      <category>CS61B</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS61B</tag>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机体系计划</title>
    <link href="undefined2020/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E8%AE%A1%E5%88%92/"/>
    <url>2020/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机知识体系"><a href="#计算机知识体系" class="headerlink" title="计算机知识体系"></a>计算机知识体系</h1><h2 id="1，概述"><a href="#1，概述" class="headerlink" title="1，概述"></a>1，概述</h2><p>本文档是一个目录页，用于构建我个人的计算机知识体系，我将把计算机的各个领域相关的资料链接都放在这个页面上，同时我会写上一些自己的学习心得和如何使用这些资料。<br>注意：我只放上链接，而不实际存储任何的内容。（本博客将会持续的更新）</p><h2 id="2，Awesome-list"><a href="#2，Awesome-list" class="headerlink" title="2，Awesome list"></a>2，Awesome list</h2><ul><li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">Github链接</a></li><li>点评：这个链接包含所有的你能想到的计算机领域的项目，非常推荐去看一看。</li></ul><h2 id="3，算法与数据结构"><a href="#3，算法与数据结构" class="headerlink" title="3，算法与数据结构"></a>3，算法与数据结构</h2><ul><li><h3 id="3-1-课程"><a href="#3-1-课程" class="headerlink" title="3.1 课程"></a>3.1 课程</h3><ul><li><a href="https://sp19.datastructur.es/index.html#cal" target="_blank" rel="noopener">伯克利CS61B</a> （非常推荐，适合入门以及深入数据结构，spring2019版本较易入门，fall2019会难一些）</li><li><a href="https://www.coursera.org/learn/algorithms-part1" target="_blank" rel="noopener">普林斯顿算法</a>（老爷子是高德纳的弟子，讲的很好，也有assignment和project可以练习）</li></ul></li><li><h3 id="3-2-书籍"><a href="#3-2-书籍" class="headerlink" title="3.2 书籍"></a>3.2 书籍</h3><ul><li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法（第4版） (豆瓣)</a></li><li><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">算法导论（原书第3版） (豆瓣)</a></li><li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">算法图解 (豆瓣)</a></li></ul></li></ul><h2 id="4，编程语言"><a href="#4，编程语言" class="headerlink" title="4，编程语言"></a>4，编程语言</h2><ul><li><h3 id="4-1-C-C"><a href="#4-1-C-C" class="headerlink" title="4.1 C/C++"></a>4.1 C/C++</h3><ul><li><strong>书籍</strong><ul><li><a href="https://book.douban.com/subject/25708312/" target="_blank" rel="noopener">C++ Primer 中文版（第 5 版） (豆瓣)</a></li><li><a href="https://book.douban.com/subject/1842426/" target="_blank" rel="noopener">Effective C++ (豆瓣)</a></li><li><a href="https://book.douban.com/subject/1091086/" target="_blank" rel="noopener">深度探索C++对象模型 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/30178902/" target="_blank" rel="noopener">Effective Modern C++ 简体中文版 (豆瓣)</a></li></ul></li><li><strong>课程</strong></li></ul></li><li><h3 id="4-2-Java"><a href="#4-2-Java" class="headerlink" title="4.2 Java"></a>4.2 Java</h3><ul><li><strong>书籍</strong><ul><li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">Java编程思想 （第4版） (豆瓣)</a></li><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">深入理解Java虚拟机（第2版） (豆瓣)</a></li><li><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">Effective java 中文版（第2版） (豆瓣)</a></li></ul></li></ul></li><li><h3 id="4-3-C"><a href="#4-3-C" class="headerlink" title="4.3 C#"></a>4.3 C#</h3><ul><li><strong>书籍</strong><ul><li><a href="https://book.douban.com/subject/24748698/" target="_blank" rel="noopener">C#图解教程 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/25843328/" target="_blank" rel="noopener">深入理解C#（第3版） (豆瓣)</a></li><li><a href="https://book.douban.com/subject/26285940/" target="_blank" rel="noopener">CLR via C# (豆瓣)</a></li></ul></li></ul></li><li><h3 id="4-4-Python"><a href="#4-4-Python" class="headerlink" title="4.4 Python"></a>4.4 Python</h3><ul><li><strong>书籍</strong><ul><li><a href="https://book.douban.com/subject/26829016/" target="_blank" rel="noopener">Python编程 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/27028517/" target="_blank" rel="noopener">流畅的Python (豆瓣)</a></li></ul></li><li><strong>课程</strong><ul><li><a href="https://cs61a.org/" target="_blank" rel="noopener">伯克利CS61A</a> (极好的计算机入门课程)</li></ul></li></ul></li><li><h3 id="4-5-函数式编程语言"><a href="#4-5-函数式编程语言" class="headerlink" title="4.5 函数式编程语言"></a>4.5 函数式编程语言</h3></li></ul><h2 id="5，编译原理"><a href="#5，编译原理" class="headerlink" title="5，编译原理"></a>5，编译原理</h2><ul><li><h3 id="5-1-书籍"><a href="#5-1-书籍" class="headerlink" title="5.1 书籍"></a>5.1 <strong>书籍</strong></h3><ul><li><a href="https://book.douban.com/subject/3296317/" target="_blank" rel="noopener">编译原理 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/2152385/" target="_blank" rel="noopener">程序设计语言 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/1923484/" target="_blank" rel="noopener">Modern Compiler Implementation in Java (豆瓣)</a></li><li><a href="https://book.douban.com/subject/3136252/" target="_blank" rel="noopener">Essentials of Programming Languages, 3rd Edition (豆瓣)</a></li><li><a href="https://book.douban.com/subject/25908672/" target="_blank" rel="noopener">两周自制脚本语言 (豆瓣)</a></li></ul></li><li><h3 id="5-2-课程"><a href="#5-2-课程" class="headerlink" title="5.2 课程"></a>5.2 <strong>课程</strong></h3><ul><li><a href="https://www.coursera.org/learn/programming-languages" target="_blank" rel="noopener">华盛顿大学编程语言</a></li><li><a href="https://see.stanford.edu/course/cs107" target="_blank" rel="noopener">Stanford Engineering Everywhere | CS107 - Programming Paradigms</a></li><li><a href="https://online.stanford.edu/courses/soe-ycscs1-compilers" target="_blank" rel="noopener">Compilers | Stanford Online</a></li><li><a href="https://mooc.study.163.com/course/1000002001?tid=1000003000&_trace_c_p_k2_=5968c09d7d1b40ec972d527351736a74#/info" target="_blank" rel="noopener">中科大编译原理 - 网易云课堂</a></li></ul></li><li><h3 id="5-3-项目"><a href="#5-3-项目" class="headerlink" title="5.3 项目"></a>5.3 项目</h3><ul><li><a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">Let’s Build A Simple Interpreter. Part 1. - Ruslan’s Blog</a></li><li><a href="https://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（0）- 前言 | 三点水</a></li></ul></li></ul><h2 id="6，计算机图形学"><a href="#6，计算机图形学" class="headerlink" title="6，计算机图形学"></a>6，计算机图形学</h2><ul><li><h3 id="6-1-书籍"><a href="#6-1-书籍" class="headerlink" title="6.1 书籍"></a>6.1 书籍</h3><ul><li><a href="https://book.douban.com/subject/1392483/" target="_blank" rel="noopener">计算机图形学 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/10777165/" target="_blank" rel="noopener">交互式计算机图形学 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/26868819/" target="_blank" rel="noopener">Fundamentals of Computer Graphics, Fourth Edition (豆瓣)</a></li><li><a href="https://book.douban.com/subject/10774590/" target="_blank" rel="noopener">OpenGL超级宝典 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/25845921/" target="_blank" rel="noopener">OpenGL ES 3.0 Programming Guide (豆瓣)</a></li></ul></li><li><h3 id="6-2-课程"><a href="#6-2-课程" class="headerlink" title="6.2 课程"></a>6.2 课程</h3><ul><li><a href="https://cs184.eecs.berkeley.edu/sp18/" target="_blank" rel="noopener">CS184 : Spring 2018</a></li><li><a href="https://cs184.eecs.berkeley.edu/sp19" target="_blank" rel="noopener">CS184 : Spring 2019</a></li><li><a href="http://web.stanford.edu/class/cs148/lectures.html" target="_blank" rel="noopener">CS 148: Introduction to Computer Graphics and Imaging</a></li><li><a href="https://www.edx.org/course/animation-and-cgi-motion-2" target="_blank" rel="noopener">Animation and CGI Motion | edX</a></li></ul></li><li><h3 id="6-3-豆列"><a href="#6-3-豆列" class="headerlink" title="6.3 豆列"></a>6.3 豆列</h3><ul><li><a href="https://www.douban.com/doulist/1445744/" target="_blank" rel="noopener">计算机图形: 入门/API类</a></li><li><a href="http://book.douban.com/doulist/1445745/" target="_blank" rel="noopener">计算机图形: Gems类</a></li><li><a href="http://book.douban.com/doulist/1445806/" target="_blank" rel="noopener">计算机图形: 专栏合集</a></li><li><a href="http://book.douban.com/doulist/1445716/" target="_blank" rel="noopener">计算机图形: 动画</a></li><li><a href="http://book.douban.com/doulist/1445735/" target="_blank" rel="noopener">计算机图形: 相关数学</a></li><li><a href="https://www.douban.com/doulist/1447740/" target="_blank" rel="noopener">计算机图形: 其他参考</a></li><li><a href="https://book.douban.com/people/miloyip/doulists" target="_blank" rel="noopener">Milo的图书豆列</a></li></ul></li><li><h3 id="6-4-学习网站"><a href="#6-4-学习网站" class="headerlink" title="6.4 学习网站"></a>6.4 学习网站</h3><ul><li><a href="https://www.scratchapixel.com/" target="_blank" rel="noopener">Scratchapixel</a></li><li><a href="http://learnopengl.com/#!Getting-started/OpenGL" target="_blank" rel="noopener">Learn OpenGL, extensive tutorial resource for learning Modern OpenGL</a></li></ul></li><li><h3 id="6-5-知乎回答合集"><a href="#6-5-知乎回答合集" class="headerlink" title="6.5 知乎回答合集"></a>6.5 知乎回答合集</h3></li></ul><h2 id="7，计算机组成-体系结构"><a href="#7，计算机组成-体系结构" class="headerlink" title="7，计算机组成/体系结构"></a>7，计算机组成/体系结构</h2><h2 id="8，计算机网络"><a href="#8，计算机网络" class="headerlink" title="8，计算机网络"></a>8，计算机网络</h2><ul><li><h3 id="8-1-书籍"><a href="#8-1-书籍" class="headerlink" title="8.1 书籍"></a>8.1 书籍</h3><ul><li><a href="https://book.douban.com/subject/2970300/" target="_blank" rel="noopener">计算机网络 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/26176870/" target="_blank" rel="noopener">计算机网络自顶向下（第6版） (豆瓣)</a></li><li><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP详解 卷1：协议 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/24737674/" target="_blank" rel="noopener">图解TCP/IP（第5版） (豆瓣)</a></li></ul></li><li><h3 id="8-2-课程"><a href="#8-2-课程" class="headerlink" title="8.2 课程"></a>8.2 课程</h3><ul><li><a href="http://cs168.io/" target="_blank" rel="noopener">伯克利CS168 Fall 2018</a></li></ul></li></ul><h2 id="9，操作系统-分布式系统"><a href="#9，操作系统-分布式系统" class="headerlink" title="9，操作系统/分布式系统"></a>9，操作系统/分布式系统</h2><ul><li><h3 id="9-1-书籍"><a href="#9-1-书籍" class="headerlink" title="9.1 书籍"></a>9.1 书籍</h3><ul><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">深入理解计算机系统（原书第3版） (豆瓣)</a></li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">现代操作系统（原书第4版） (豆瓣)</a></li><li><a href="https://book.douban.com/subject/2109679/" target="_blank" rel="noopener">操作系统概念 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/3735649/" target="_blank" rel="noopener">Orange’S:一个操作系统的实现 (豆瓣)</a></li><li><a href="https://book.douban.com/subject/11530329/" target="_blank" rel="noopener">30天自制操作系统 (豆瓣)</a></li></ul></li><li><h3 id="9-2-课程"><a href="#9-2-课程" class="headerlink" title="9.2 课程"></a>9.2 课程</h3><ul><li><a href="https://inst.eecs.berkeley.edu/~cs162/fa18/" target="_blank" rel="noopener">伯克利CS162 — Fall 2018</a></li><li><a href="http://www.cs.cmu.edu/~./213/index.html" target="_blank" rel="noopener">CMU 15-213: Introduction to Computer Systems</a></li><li><a href="http://www.icourse163.org/course/NJU-1001625001" target="_blank" rel="noopener">南京大学 中国大学MOOC(慕课) 计算机系统基础(一)</a></li></ul></li><li><h3 id="9-3-博客"><a href="#9-3-博客" class="headerlink" title="9.3 博客"></a>9.3 博客</h3><ul><li><a href="https://wdxtub.com/csapp/thin-csapp-0/2016/04/16/" target="_blank" rel="noopener">【读薄 CSAPP】零 系列概览 | 小土刀 2.0</a></li></ul></li><li><h3 id="9-4-项目"><a href="#9-4-项目" class="headerlink" title="9.4 项目"></a>9.4 项目</h3></li></ul><h2 id="10，AI-机器学习-深度学习"><a href="#10，AI-机器学习-深度学习" class="headerlink" title="10，AI/机器学习/深度学习"></a>10，AI/机器学习/深度学习</h2><h2 id="11，数学"><a href="#11，数学" class="headerlink" title="11，数学"></a>11，数学</h2><ul><li><h3 id="11-1-线性代数"><a href="#11-1-线性代数" class="headerlink" title="11.1 线性代数"></a>11.1 线性代数</h3><ul><li>课程<ul><li>MIT线性代数</li></ul></li><li>书籍</li></ul></li><li><h3 id="11-2-微积分-数学分析"><a href="#11-2-微积分-数学分析" class="headerlink" title="11.2 微积分/数学分析"></a>11.2 微积分/数学分析</h3></li><li><h3 id="11-3-数值计算"><a href="#11-3-数值计算" class="headerlink" title="11.3 数值计算"></a>11.3 数值计算</h3></li></ul><h2 id="11，-video-game-游戏开发"><a href="#11，-video-game-游戏开发" class="headerlink" title="11，:video_game: 游戏开发"></a>11，:video_game: 游戏开发</h2><h2 id="12，移动应用开发"><a href="#12，移动应用开发" class="headerlink" title="12，移动应用开发"></a>12，移动应用开发</h2><h2 id="13，网络应用开发"><a href="#13，网络应用开发" class="headerlink" title="13，网络应用开发"></a>13，网络应用开发</h2><h2 id="14，版本控制-工具网站"><a href="#14，版本控制-工具网站" class="headerlink" title="14，版本控制/工具网站"></a>14，版本控制/工具网站</h2><h2 id="14，知乎回答汇总"><a href="#14，知乎回答汇总" class="headerlink" title="14，知乎回答汇总"></a>14，知乎回答汇总</h2>]]></content>
    
    
    <categories>
      
      <category>计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS184 Project2总结</title>
    <link href="undefined2019/04/17/CS184-Project2%E6%80%BB%E7%BB%93/"/>
    <url>2019/04/17/CS184-Project2%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Project2"><a href="#Project2" class="headerlink" title="Project2"></a>Project2</h1><center><img src="/img/Post_CS184_project2/title.jpeg" srcset="/img/loading.gif" width="900px" align="middle"/></center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次是CS184的第二个project，主要内容是贝塞尔曲线和曲面，样条和曲面细分。包含了CS184 Spring2019课程第八节和第九节。Section1 是关于贝塞尔曲线和曲面的，Section2 是关于三角形mesh的曲面细分。涉及实现贝塞尔曲面的de Casteljau’s 算法。曲面细分需要用到一种图形学相关数据结构，主要是halfedge mesh这种数据结构。参考<a href="https://cs184.eecs.berkeley.edu/sp19/article/15/the-half-edge-data-structure" target="_blank" rel="noopener">这篇文章</a><br>本次所有需要需改的代码均在<code>student_code.cpp</code>这个文件里。</p><h2 id="Section-I-Bezier-Curves-and-Surfaces"><a href="#Section-I-Bezier-Curves-and-Surfaces" class="headerlink" title="Section I: Bezier Curves and Surfaces"></a>Section I: Bezier Curves and Surfaces</h2><h3 id="Part-1-Bezier-curves-with-1D-de-Casteljau-subdivision"><a href="#Part-1-Bezier-curves-with-1D-de-Casteljau-subdivision" class="headerlink" title="Part 1: Bezier curves with 1D de Casteljau subdivision"></a>Part 1: Bezier curves with 1D de Casteljau subdivision</h3><h4 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>第一部分关于1D de Casteljau算法的实现，这个算法是比较常见的找到贝塞尔曲面上一点的方法。<br>需要修改 <code>BezierCurve::evaluateStep</code> 这个函数，<code>BezierCurve</code> 这个类有一个控制点的<code>vector</code> ，提前会把控制点加载进来。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>这个算法的原理参见下图，比方说一开始四个控制点（我称为一阶控制点），每两个点进行一次插值（获取一个二阶点），一轮插值之后。变为三个控制点，于是再次对这三个二阶进行两两插值，重复这个过程，直到最后一个点。<br><br></p><center><img src="/img/Post_CS184_project2/part1-1.png" srcset="/img/loading.gif" width="700px" align="middle"></center><br><p><code>BezierCurve</code> 类有下面两个<code>vector</code>，<code>evaluatedLevels[0]</code> 就是初始的四个控制点（一阶控制点）,<code>evaluatedLevels[1]</code>就是二阶控制点，依次类推。<br><br></p><pre><code class="c++">    std::vector&lt;Vector2D&gt; controlPoints; // The original control points of the Bezier curve    std::vector&lt; std::vector&lt;Vector2D&gt; &gt; evaluatedLevels; // Levels of points evaluated through de Casteljau</code></pre><br><p>这个还蛮简单的，实现代码如下。</p><pre><code class="c++">    void BezierCurve::evaluateStep()    {        // TODO Part 1.        // Perform one step of the Bezier curve&#39;s evaluation at t using de Casteljau&#39;s algorithm for subdivision.        // Store all of the intermediate control points into the 2D vector evaluatedLevels.        int maxLevel = numControlPoints;        int currentLevel  = evaluatedLevels.size();        if(currentLevel == maxLevel)            return;        else        {            std::vector&lt;Vector2D&gt; currentLevelPoints = evaluatedLevels[evaluatedLevels.size()-1];            int nextLevelSize = currentLevelPoints.size() - 1;            std::vector&lt;Vector2D&gt; newLevelPoints(nextLevelSize);            for(int i = 0; i &lt; nextLevelSize; i++)            {                newLevelPoints[i] = currentLevelPoints[i] * (1 - t) + currentLevelPoints[i + 1] * t;            }            evaluatedLevels.push_back(newLevelPoints);        }    }</code></pre><br><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>结果如下<br></p><center>    <img src="/img/Post_CS184_project2/part1-2.png" srcset="/img/loading.gif" width="350px"/>    <img src="/img/Post_CS184_project2/part1-3.png" srcset="/img/loading.gif" width="350px"/></center><h3 id="Part-2-Bezier-surfaces-with-separable-1D-de-Casteljau-subdivision"><a href="#Part-2-Bezier-surfaces-with-separable-1D-de-Casteljau-subdivision" class="headerlink" title="Part 2: Bezier surfaces with separable 1D de Casteljau subdivision"></a>Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3><h4 id="题目介绍-1"><a href="#题目介绍-1" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>上一题是贝塞尔曲线，这一题则是贝塞尔曲面，其实道理是一样的，只不过现在我们找到多条贝塞尔曲线，<br>之后加入第三个维度，再次运用<code>de Casteljau</code>算法形成曲面。如下所示</p><center>    <img src="/img/Post_CS184_project2/part2-1.png" srcset="/img/loading.gif" width="400px"/>    <img src="/img/Post_CS184_project2/part2-3.png" srcset="/img/loading.gif" width="400px"/></center><br><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>本题相关的类是<code>BezierPatch</code>，该类和第一题中的<code>BezierCurve</code>类似，这是关于曲面。<br>实现两个函数，<code>BezierPatch::evaluate</code>和<code>BezierPatch::evaluate1D</code>。首先和第一题一样<code>controlPoints</code>这个二维数组（假设是4*4），对每四个control point做一次1D de Casteljau，形成四个点，最后对这个四个点再做一次，得到曲面上的一点。<br>算法流程如下图。</p><center>    <img src="/img/Post_CS184_project2/part2-4.png" srcset="/img/loading.gif" width="600px"/></center><br><pre><code class="c++">Vector3D BezierPatch::evaluate(double u, double v) const    {        // TODO Part 2.        // Evaluate the Bezier surface at parameters (u, v) through 2D de Casteljau subdivision.        // (i.e. Unlike Part 1 where we performed one subdivision level per call to evaluateStep, this function        // should apply de Casteljau&#39;s algorithm until it computes the final, evaluated point on the surface)        // 现在第一次形成四条曲线用的参数u，第二次形成曲面用的参数v        std::vector&lt;Vector3D&gt; p;        for(int i = 0; i &lt; controlPoints.size(); ++i){            p.push_back(evaluate1D(controlPoints[i], u));        }        return evaluate1D(p,v);    }    //返回1D贝塞尔曲线上的一个点    Vector3D BezierPatch::evaluate1D(std::vector&lt;Vector3D&gt; points, double t) const    {        // TODO Part 2.        // Optional helper function that you might find useful to implement as an abstraction when implementing BezierPatch::evaluate.        // Given an array of 4 points that lie on a single curve, evaluates the Bezier curve at parameter t using 1D de Casteljau subdivision.        //我的解决方案        std::vector&lt;Vector3D&gt; tmpControlPoints(points);        std::vector&lt;Vector3D&gt; finalControlPoints;        while (tmpControlPoints.size() &gt;= 2)        {            finalControlPoints.clear();            for (int j = 1; j &lt; tmpControlPoints.size(); j++) {                Vector3D tmp(tmpControlPoints[j - 1] * (1 - t) + tmpControlPoints[j] * t);                finalControlPoints.push_back(tmp);            }            tmpControlPoints.clear();            tmpControlPoints.assign(finalControlPoints.begin(), finalControlPoints.end());        }        Vector3D result;        if (!finalControlPoints.empty())        {            result = finalControlPoints[0];        }        return result;    }</code></pre><br><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><p>在工作目录下运行命令</p><pre><code>../meshedit /bez/teapot.bez</code></pre><p>得到一个经典的犹他茶壶。</p><center>    <img src="/img/Post_CS184_project2/part2-5.png" srcset="/img/loading.gif" width="500px"/></center><br><h2 id="Section-II-Loop-Subdivision-of-General-Triangle-Meshes"><a href="#Section-II-Loop-Subdivision-of-General-Triangle-Meshes" class="headerlink" title="Section II: Loop Subdivision of General Triangle Meshes"></a>Section II: Loop Subdivision of General Triangle Meshes</h2><p>第二个section是关于曲面细分，主要涉及halfedgemesh这个数据结构，很有意思的一个数据结构，参考<a href="https://cs184.eecs.berkeley.edu/sp19/article/15/the-half-edge-data-structure" target="_blank" rel="noopener">这篇文章</a><br><br></p><h3 id="Part-3-Average-normals-for-half-edge-meshes"><a href="#Part-3-Average-normals-for-half-edge-meshes" class="headerlink" title="Part 3: Average normals for half-edge meshes"></a>Part 3: Average normals for half-edge meshes</h3><h4 id="题目介绍-2"><a href="#题目介绍-2" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>本题求一个顶点处平均权重的normal，每个顶点有一个normal，但是顶点处的normal不像平面那么直观，一个平面的normal垂直于这个平面上所有的向量，这很明显。但是对于一个vertex的normal，我们是通过将这个顶点周围的所有相邻的平面的normal加权求和。<br><br>这么做的好处有什么呢，就是可以使得最终显示在屏幕上的图形更加的平滑。参见运行结果。<br>原因是计算光照的时候我们要用normal的信息，在本题之前是直接使用每个三角mesh的normal（也就是垂直于该平面的normal），然后采用一个光照模型比如<code>phong shading</code>。不使用vertex normal，直接用每个三角面的normal算光照的话单个三角面内的像素计算出来的颜色都一样<br>但是使用了vertex normal，比方说用phong shading，就是对三角面的三个顶点分别计算，这样三角形内的每个像素再根据这三个顶点做差值，所以显示出来的图像就是平滑的而不是一个个三角面。<br><br>总结一下就是根据三个顶点的颜色插值得到平滑图形，而计算三个顶点光照和颜色需要normal。</p><center>    <img src="/img/Post_CS184_project2/part3-6.png" srcset="/img/loading.gif" width="400px" />    <img src="/img/Post_CS184_project2/part3-1.png" width="4    00px" /></center><h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><p>只需要完成<code>Vertex::normal</code>这个函数，我们对于该顶点相邻的所有平面（三角形）normal加权求和，权重就是三角形的面积，也就是面积越大权重越大。那么怎么遍历所有的face呢？就是采用<code>halfedgemesh</code>这个数据结构，该数据结构是一整个mesh（有可能整个模型就这一个mesh），这个mesh包含了<code>edge</code>，<code>face</code>，<code>vertex</code>，<code>halfedge</code>的链表。其的核心就是<code>halfedge</code>类，<code>halfedge</code>就是一个有向向量，每个<code>halfedge</code>都关联五个其他基本的几何单位，<code>halfedge</code>有指向起点<code>vertex</code>的iterator（c++中类似指针的一个概念），指向<code>edge</code>，<code>face</code>，下一个<code>halfedge</code>和<code>twin halfedge</code>（同一条<code>edge</code>上反方向的一个<code>halfedge</code>）的iterator，这样<code>halfedge</code>就像一个中枢站一样。如上图所示，每个<code>vertex</code>都有关联的一个<code>halfedge</code>，这个<code>halfedge</code>是任意一个以该<code>vertex</code>为起点的<code>halfedge</code>。<br></p><pre><code class="c++">         HalfedgeIter _twin; ///&lt; halfedge on the &quot;other side&quot; of the edge         HalfedgeIter _next; ///&lt; next halfedge around the current face         VertexIter _vertex; ///&lt; vertex at the &quot;base&quot; or &quot;root&quot; of this halfedge         EdgeIter _edge; ///&lt; associated edge         FaceIter _face; ///&lt; face containing this halfedge</code></pre><br>代码如下<pre><code class="c++">Vector3D Vertex::normal(void) const    {        // TODO Part 3.        // TODO Returns an approximate unit normal at this vertex, computed by        // TODO taking the area-weighted average of the normals of neighboring        // TODO triangles, then normalizing.        Vector3D normal(0,0,0);         // initialize a vector to store your normal sum        HalfedgeCIter h = halfedge();   // Since we&#39;re in a Vertex, this returns a halfedge        HalfedgeCIter hConst = h;        double sum = 0.;        do        {            //要取得是平面的normal，而不是点的normal            Vector3D nighborNormal(h-&gt;face()-&gt;normal());            //下面是两个向量，然后做叉乘            Vector3D v1(h-&gt;vertex()-&gt;position - (h-&gt;twin()-&gt;vertex())-&gt;position);            Vector3D v2(h-&gt;vertex()-&gt;position - (h-&gt;twin()-&gt;next()-&gt;twin()-&gt;vertex()-&gt;position));            double tmpWeight = cross(v1, v2).norm();            sum += tmpWeight;            //三角形面积的两倍（平行四边形的面积）乘上normal累加上去            normal += nighborNormal * tmpWeight;            //std::cout&lt;&lt; &quot;暂时输出normal为&quot; &lt;&lt; normal&lt;&lt;std::endl;            h = h-&gt;twin()-&gt;next();        }while(h != hConst);        //最后归一化        normal /= sum;        return normal;    }</code></pre><h4 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h4><p> 同样运行以下命令<br></p><pre><code> ../meshedit /dae/teapot.dae</code></pre><br>然后我们按下Q键，就会显示重新计算normal之后的模型，可以看到光滑了很多。按下w键是切换到GLSL shader。<center>    <img src="/img/Post_CS184_project2/part3-2.png" srcset="/img/loading.gif" width="400px" />    <img src="/img/Post_CS184_project2/part3-3.png" srcset="/img/loading.gif" width="400px" /></center><center>    <img src="/img/Post_CS184_project2/part3-4.png" srcset="/img/loading.gif" width="400px" />    <img src="/img/Post_CS184_project2/part3-5.png" srcset="/img/loading.gif" width="400px" /></center><h3 id="Part-4-Half-edge-flip"><a href="#Part-4-Half-edge-flip" class="headerlink" title="Part 4: Half-edge flip"></a>Part 4: Half-edge flip</h3><h4 id="题目介绍-3"><a href="#题目介绍-3" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>本题是flip翻转half-edge，将边的连接变换。</p><center>    <img src="/img/Post_CS184_project2/part4-1.png" srcset="/img/loading.gif" width="600px" />    </center><br>#### 实现原理这道题只要遵循[这篇guide](http://15462.courses.cs.cmu.edu/fall2015content/misc/HalfedgeEdgeOpImplementationGuide.pdf)就不会有什么问题了，就是一些繁琐的操作。但是思路很好，先把图画出来，原先有哪些edge，vertex，halfedge，face，然后在画出flip之后的图，看看这四种基本几何单位又有哪些。然后修改各个类的iterator指向就完事儿了。我的实现和guide中的图一致。<br>代码如下<br><pre><code class="c++">EdgeIter HalfedgeMesh::flipEdge(EdgeIter e0)    {        // TODO Part 4.        // TODO This method should flip the given edge and return an iterator to the flipped edge.        // 首先获取所有的可能改变的元素        FaceIter f0 = e0-&gt;halfedge()-&gt;face();        FaceIter f1 = e0-&gt;halfedge()-&gt;twin()-&gt;face();        if(f0-&gt;isBoundary() || f1-&gt;isBoundary())        {            return e0;        }        HalfedgeIter h0 = e0-&gt;halfedge();        HalfedgeIter h1 = h0-&gt;next();        HalfedgeIter h2 = h1-&gt;next();        HalfedgeIter h3 = h0-&gt;twin();        HalfedgeIter h4 = h3-&gt;next();        HalfedgeIter h5 = h4-&gt;next();        HalfedgeIter h6 = h1-&gt;twin();        HalfedgeIter h7 = h2-&gt;twin();        HalfedgeIter h8 = h4-&gt;twin();        HalfedgeIter h9 = h5-&gt;twin();        VertexIter v0 = h0-&gt;vertex();        VertexIter v1 = h3-&gt;vertex();        VertexIter v2 = h6-&gt;vertex();        VertexIter v3 = h8-&gt;vertex();        EdgeIter e1 = h1-&gt;edge();        EdgeIter e2 = h2-&gt;edge();        EdgeIter e3 = h4-&gt;edge();        EdgeIter e4 = h5-&gt;edge();        //接着重新分配        //想了一下，分配顺序应该没有关系        h0-&gt;next() = h1;        h0-&gt;twin() = h3;        h0-&gt;face() = f0;        h0-&gt;vertex() = v3;        h0-&gt;edge() = e0;        h1-&gt;next() = h2;        h1-&gt;twin() = h7;        h1-&gt;face() = f0;        h1-&gt;vertex() = v2;        h1-&gt;edge() = e2;        h2-&gt;next() = h0;        h2-&gt;twin() = h8;        h2-&gt;face() = f0;        h2-&gt;vertex() = v0;        h2-&gt;edge() = e3;        h3-&gt;next() = h4;        h3-&gt;twin() = h0;        h3-&gt;face() = f1;        h3-&gt;vertex() = v2;        h3-&gt;edge() = e0;        h4-&gt;next() = h5;        h4-&gt;twin() = h9;        h4-&gt;face() = f1;        h4-&gt;vertex() = v3;        h4-&gt;edge() = e4;        h5-&gt;next() = h3;        h5-&gt;twin() = h6;        h5-&gt;face() = f1;        h5-&gt;vertex() = v1;        h5-&gt;edge() = e1;        h6-&gt;next() = h6-&gt;next();        h6-&gt;twin() = h5;        h6-&gt;face() = h6-&gt;face();        h6-&gt;vertex() = v2;        h6-&gt;edge() = e1;        h7-&gt;next() = h7-&gt;next();        h7-&gt;twin() = h1;        h7-&gt;face() = h7-&gt;face();        h7-&gt;vertex() = v0;        h7-&gt;edge() = e2;        h8-&gt;next() = h8-&gt;next();        h8-&gt;twin() = h2;        h8-&gt;face() = h8-&gt;face();        h8-&gt;vertex() = v3;        h8-&gt;edge() = e3;        h9-&gt;next() = h9-&gt;next();        h9-&gt;twin() = h4;        h9-&gt;face() = h9-&gt;face();        h9-&gt;vertex() = v1;        h9-&gt;edge() = e4;        v0-&gt;halfedge() = h2;        v1-&gt;halfedge() = h5;        v2-&gt;halfedge() = h3;        v3-&gt;halfedge() = h0;        e0-&gt;halfedge() = h0;        e1-&gt;halfedge() = h5;        e2-&gt;halfedge() = h1;        e3-&gt;halfedge() = h2;        e4-&gt;halfedge() = h4;        f0-&gt;halfedge() = h0;        f1-&gt;halfedge() = h3;        return e0;    }</code></pre><br>#### 运行结果在GUI界面中选中边，然后按下S键即可。<center>    <img src="/img/Post_CS184_project2/part4-2.png" srcset="/img/loading.gif" width="350px" />        <img src="/img/Post_CS184_project2/part4-3.png" srcset="/img/loading.gif" width="350px" />    </center><h3 id="Part-5-Half-edge-split"><a href="#Part-5-Half-edge-split" class="headerlink" title="Part 5: Half-edge split"></a>Part 5: Half-edge split</h3><h4 id="题目介绍-4"><a href="#题目介绍-4" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>本题和上一题思路类似，只不过变成了split分割边。如下所示<br></p><center>    <img src="/img/Post_CS184_project2/part5-1.png" srcset="/img/loading.gif" width="600px" /></center><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p>同样参考这篇guide，这次需要新加上几个点，比如说一个新的vertex，三条edge，六条新的halfedge，两个face。依旧是修改一堆iterator，我的实现图如下。<br></p><center>    <img src="/img/Post_CS184_project2/part5-3.jpg" srcset="/img/loading.gif" width="400px" height="400px" />    <img src="/img/Post_CS184_project2/part5-4.jpg" srcset="/img/loading.gif" width="400px" height="400px"/></center><pre><code class="c++">VertexIter HalfedgeMesh::splitEdge(EdgeIter e0)    {        // TODO Part 5.        // TODO This method should split the given edge and return an iterator to the newly inserted vertex.        // TODO The halfedge of this vertex should point along the edge that was split, rather than the new edges.        FaceIter f0 = e0-&gt;halfedge()-&gt;face();        FaceIter f1 = e0-&gt;halfedge()-&gt;twin()-&gt;face();        if(f0-&gt;isBoundary() || f1-&gt;isBoundary())        {            return e0-&gt;halfedge()-&gt;vertex();        }        HalfedgeIter h0 = e0-&gt;halfedge();        HalfedgeIter h1 = h0-&gt;next();        HalfedgeIter h2 = h1-&gt;next();        HalfedgeIter h3 = h0-&gt;twin();        HalfedgeIter h4 = h3-&gt;next();        HalfedgeIter h5 = h4-&gt;next();        HalfedgeIter h6 = h1-&gt;twin();        HalfedgeIter h7 = h2-&gt;twin();        HalfedgeIter h8 = h4-&gt;twin();        HalfedgeIter h9 = h5-&gt;twin();        VertexIter v0 = h0-&gt;vertex();        VertexIter v1 = h3-&gt;vertex();        VertexIter v2 = h6-&gt;vertex();        VertexIter v3 = h8-&gt;vertex();        EdgeIter e1 = h1-&gt;edge();        EdgeIter e2 = h2-&gt;edge();        EdgeIter e3 = h4-&gt;edge();        EdgeIter e4 = h5-&gt;edge();        //创建新的halfElement        //这里创建的时候已经加入mesh的list里面去了，所以确实改变了mesh的list        //三条新的edge        EdgeIter e5 = newEdge();        EdgeIter e6 = newEdge();        EdgeIter e7 = newEdge();        //六个新的halfedge        HalfedgeIter h10 = newHalfedge();        HalfedgeIter h11 = newHalfedge();        HalfedgeIter h12 = newHalfedge();        HalfedgeIter h13 = newHalfedge();        HalfedgeIter h14 = newHalfedge();        HalfedgeIter h15 = newHalfedge();        //两个新的face        FaceIter f2 = newFace();        FaceIter f3 = newFace();        //一个新的vertex        VertexIter v4 = newVertex();        v4-&gt;position = (v1-&gt;position + v0-&gt;position) / 2;        //重新分配        h0-&gt;setNeighbors(h1, h3, v4, e0, f0);        h1-&gt;setNeighbors(h10, h6, v1, e1, f0);        h2-&gt;setNeighbors(h14, h7, v2, e2, f3);        h3-&gt;setNeighbors(h11, h0, v1, e0, f1);        h4-&gt;setNeighbors(h12, h8, v0, e3, f2);        h5-&gt;setNeighbors(h3, h9, v3, e4, f1);        h6-&gt;setNeighbors(h6-&gt;next(), h1, v2, e1, h6-&gt;face());        h7-&gt;setNeighbors(h7-&gt;next(), h2, v0, e2, h7-&gt;face());        h8-&gt;setNeighbors(h8-&gt;next(), h4, v3, e3, h8-&gt;face());        h9-&gt;setNeighbors(h9-&gt;next(), h5, v1, e4, h9-&gt;face());        h10-&gt;setNeighbors(h0, h15, v2, e5, f0);        h11-&gt;setNeighbors(h5, h12, v4, e7, f1);        h12-&gt;setNeighbors(h13, h11, v3, e7, f2);        h13-&gt;setNeighbors(h4, h14, v4, e6, f2);        h14-&gt;setNeighbors(h15, h13, v0, e6, f3);        h15-&gt;setNeighbors(h2, h10, v4, e5, f3);        e0-&gt;halfedge() = h0;        e1-&gt;halfedge() = h1;        e2-&gt;halfedge() = h2;        e3-&gt;halfedge() = h4;        e4-&gt;halfedge() = h5;        e5-&gt;halfedge() = h10;        e6-&gt;halfedge() = h14;        e7-&gt;halfedge() = h11;        f0-&gt;halfedge() = h0;        f1-&gt;halfedge() = h3;        f2-&gt;halfedge() = h4;        f3-&gt;halfedge() = h2;        v0-&gt;halfedge() = h4;        v1-&gt;halfedge() = h3;        v2-&gt;halfedge() = h2;        v3-&gt;halfedge() = h5;        v4-&gt;halfedge() = h0;        return v4;    }</code></pre><br><h4 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果"></a>运行结果</h4><p>我随便split，不是很有美感2333.</p><center>    <img src="/img/Post_CS184_project2/part5-2.png" srcset="/img/loading.gif" width="400px" /></center><h3 id="Part-6-Loop-subdivision-for-mesh-upsampling"><a href="#Part-6-Loop-subdivision-for-mesh-upsampling" class="headerlink" title="Part 6: Loop subdivision for mesh upsampling"></a>Part 6: Loop subdivision for mesh upsampling</h3><h4 id="题目介绍-5"><a href="#题目介绍-5" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>曲面细分是最后一题也是总体上最复杂的一题，这一题的步骤很多，出了问题debug起来也比较复杂。我会一步一步说明。首先说一说曲面细分，曲面细分就是把一个三角面分割成多个子面（比方说四个），这样增加总体的face，使得模型可以变得更加精细。如下图</p><center>    <img src="/img/Post_CS184_project2/part6-1.png" srcset="/img/loading.gif" width="600px" /></center><h4 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><p>（1）首先遍历mesh中的全部顶点，将每个顶点的<code>isNew</code>属性标记为false，同时计算每个顶点在曲面细分之后的新位置，存在该顶点的<code>newPosition</code>属性之中。 计算方法如下，新创建的点根据八分之三，八分之一的权重加权求和。旧的顶点在曲面细分之后也会有一个新的位置，计算方式也是加权求和，与自身相邻的顶点权重是u，自身权重是1-(n*u)。</p><center>  <img src="/img/Post_CS184_project2/part6-2.png" srcset="/img/loading.gif" width="600px" /></center></li><li><p>（2）然后遍历全部的edge，确定将要创建的新点的位置。</p></li><li><p>（3） 创建一个新的originEdgeList，这里之所以要复制一个Edgelist，而且这个list存储的是指向指向edge的iterator的iterator。<br><br>是因为如果split了edge，那么mesh的edge链表就会添加进指向新创建的edge的iterator，那么遍历的时候就会遍历到这些新创建的然后再次split，陷入死循环。</p></li><li><p>（4）split全部的edge，记住要遍历originEdgeList，然后设置新创建的订点的<code>newPosition</code>属性以及新创建的edge的<code>isNew</code>属性。这些属性的设置非常关键！！！因为倒数第二步的时候会根据这些属性来决定那些边需要flip。</p></li><li><p>（5）flip所有连接 <em>新顶点</em>和 <em>旧顶点</em>的 <em>新边</em>！！！之所以先split再flip是这样实现起来方便一些。</p>  <center>      <img src="/img/Post_CS184_project2/part6-3.png" srcset="/img/loading.gif" width="600px" />  </center></li><li><p>（6）再次遍历一遍所有的顶点，将每个顶点的新位置覆盖当前位置。</p><br></li></ul><pre><code class="c++">    void MeshResampler::upsample(HalfedgeMesh &amp;mesh)    {        // TODO Part 6.        // This routine should increase the number of triangles in the mesh using Loop subdivision.        // Each vertex and edge of the original surface can be associated with a vertex in the new (subdivided) surface.        // Therefore, our strategy for computing the subdivided vertex locations is to *first* compute the new positions        // using the connectity of the original (coarse) mesh; navigating this mesh will be much easier than navigating        // the new subdivided (fine) mesh, which has more elements to traverse. We will then assign vertex positions in        // the new mesh based on the values we computed for the original mesh.        // TODO Compute new positions for all the vertices in the input mesh, using the Loop subdivision rule,        // TODO and store them in Vertex::newPosition. At this point, we also want to mark each vertex as being        // TODO a vertex of the original mesh.        // 第一步，计算旧顶点的新位置同时标记isNew为false。        for(auto it = mesh.verticesBegin(); it!= mesh.verticesEnd(); it++)        {            //先计算新的位置            it-&gt;isNew = false;            Vector3D newPosition(0, 0, 0);            float sum = 0;            auto nit = it-&gt;halfedge()-&gt;twin();            auto originNit = nit;            auto n = it-&gt;degree();            //注意！！！！浮点数，如果直接3/16是0            float u = (n == 3) ? (3.0/16.0) : (3.0 / (8.0 * n));            do{                sum += u;                newPosition = newPosition + u * (nit-&gt;vertex()-&gt;position);                nit = nit-&gt;next()-&gt;twin();            }while (nit != originNit);            sum += 1 - n*u;            newPosition = newPosition + (1.0 - n*u) * it-&gt;position;            newPosition = newPosition / sum;            it-&gt;newPosition = newPosition;        }        // TODO Next, compute the updated vertex positions associated with edges, and store it in Edge::newPosition.        //第二步计算所有新点的位置（每个edge上一个新的点），然后存在edge的newposition属性里        for(auto it = mesh.edgesBegin(); it!=mesh.edgesEnd(); it++)        {            //每个边上一个新的点            Vector3D newPosition(0, 0, 0);            if(it-&gt;halfedge()-&gt;face()-&gt;isBoundary() || it-&gt;halfedge()-&gt;twin()-&gt;face()-&gt;isBoundary())            {                //边界情况直接中点                newPosition = it-&gt;halfedge()-&gt;vertex()-&gt;position / 2.0 + it-&gt;halfedge()-&gt;twin()-&gt;vertex()-&gt;position / 2.0;            }            else            {                Vector3D v0 = it-&gt;halfedge()-&gt;vertex()-&gt;position;                Vector3D v1 = it-&gt;halfedge()-&gt;twin()-&gt;vertex()-&gt;position;                Vector3D v2 = it-&gt;halfedge()-&gt;next()-&gt;twin()-&gt;vertex()-&gt;position;                Vector3D v3 = it-&gt;halfedge()-&gt;twin()-&gt;next()-&gt;twin()-&gt;vertex()-&gt;position;                //注意啦，这里也被round to zero了，记住浮点数                newPosition = v0 * 3.0/8.0 + v1 * 3.0/8.0 + v2 * 1.0/8.0 + v3 * 1.0/8.0;            }            it-&gt;newPosition = newPosition;        }        // TODO Next, we&#39;re going to split every edge in the mesh, in any order.  For future        // TODO reference, we&#39;re also going to store some information about which subdivided        // TODO edges come from splitting an edge in the original mesh, and which edges are new,        // TODO by setting the flat Edge::isNew.  Note that in this loop, we only want to iterate        // TODO over edges of the original mesh---otherwise, we&#39;ll end up splitting edges that we        // TODO just split (and the loop will never end!)        //第三步，复制所有指向edge的iterator        vector&lt;EdgeIter&gt; originEdgeList;        auto copyIt = mesh.edgesBegin();        do{            auto newIt = copyIt;            newIt-&gt;isNew = false;               //一开始遍历的时候每次都改成false            originEdgeList.push_back(newIt);            copyIt++;        }while(copyIt != mesh.edgesEnd());        //第四步，split所有的边        //注意这里，it是EdgeIter的iterator，而*it才是EdgeIter类型        int countIt = 0;        for(auto it = originEdgeList.begin(); it != originEdgeList.end(); it++)        {            // 返回split之后的点            countIt++;            auto v = mesh.splitEdge(*it);            // 注意isNew的修改,这里将除了最初的edge以外的新创建的edge全部改为true;            v-&gt;isNew = true;            // newPosition 到 position的时候就为空了。            v-&gt;newPosition = (*it)-&gt;newPosition;            auto newHalfIt = v-&gt;halfedge();            newHalfIt-&gt;edge()-&gt;isNew = false;            newHalfIt-&gt;twin()-&gt;next()-&gt;edge()-&gt;isNew = true;            newHalfIt-&gt;twin()-&gt;next()-&gt;twin()-&gt;next()-&gt;edge()-&gt;isNew = false;            newHalfIt-&gt;next()-&gt;next()-&gt;edge()-&gt;isNew = true;        }        // TODO Now flip any new edge that connects an old and new vertex.        // 第五步，flip所有连接新点和旧点的新边。        for(auto it = mesh.edgesBegin(); it != mesh.edgesEnd(); it++)        {            // != 与异或的功能一致            if(it-&gt;halfedge()-&gt;vertex()-&gt;isNew != it-&gt;halfedge()-&gt;twin()-&gt;vertex()-&gt;isNew )            {                if(it-&gt;isNew)                    mesh.flipEdge(it);            }        }        // TODO Finally, copy the new vertex positions into final Vertex::position.        // 第六步，最后遍历一遍全部顶点，将新位置赋值给当前位置        for(auto it = mesh.verticesBegin(); it != mesh.verticesEnd(); it++)        {            it-&gt;position = it-&gt;newPosition;        }    }</code></pre><h4 id="运行结果-4"><a href="#运行结果-4" class="headerlink" title="运行结果"></a>运行结果</h4><p>下面分别是没有曲面细分，进行一次曲面细分，进行两次曲面细分的结果。</p><center>    <img src="/img/Post_CS184_project2/part6-5.png" srcset="/img/loading.gif" width="600px" /></center><center>    <img src="/img/Post_CS184_project2/part6-4.png" srcset="/img/loading.gif" width="600px" /></center><center>    <img src="/img/Post_CS184_project2/part6-6.png" srcset="/img/loading.gif" width="600px" /></center><br>（ps：这次的project下文件夹dae里有好多模型数据，大家可以玩玩看，而且还有最后一个自选的模型模块，我偷懒没搞，下次有机会再把这个坑填上去吧)<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次project的前面部分是比上一个简单一些的，通过这次project，基本上了解了贝塞尔曲线，de Casteljau算法，曲面细分，一个很有意思的数据结构halfedgemesh。但是感觉自己的知识还是很浅薄啊，尚需努力，我可是要立志成为图形学master的男人啊kora！！！</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>计算机课程</tag>
      
      <tag>项目总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS184 Project1总结</title>
    <link href="undefined2019/03/18/CS184-Project1%E6%80%BB%E7%BB%93/"/>
    <url>2019/03/18/CS184-Project1%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Project-1-Rasterizer"><a href="#Project-1-Rasterizer" class="headerlink" title="Project 1: Rasterizer"></a>Project 1: Rasterizer</h1><center><img src="https://cs184.eecs.berkeley.edu/cs184_sp16_content/article_images/3_1.jpg" srcset="/img/loading.gif" width="900px" align="middle"/></center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一个project的内容覆盖CS184从spring2019第一课到第五课的内容，包含了三角形光栅化<br>绘制，基本的矩阵变换和采样。总共是两个Section，七个part，由于第七个part属于个人自由<br>发挥选做内容。。本人由于懒没有做，因此只有前六个part。Project1采用了CS184教学团队<br>自己开发的GUI和图形库CGL，貌似是在OpenGL上封装了一层。详细的初始化说明请参考<a href="./README.md">README.md</a>。完整的参考实现请访问我的<a href="https://github.com/StoicLD/CS184/tree/master/p1-rasterizer" target="_blank" rel="noopener">git repo</a>。</p><h2 id="Section-I-Rasterization"><a href="#Section-I-Rasterization" class="headerlink" title="Section I: Rasterization"></a>Section I: Rasterization</h2><h3 id="Part-1-Rasterizing-single-color-triangles"><a href="#Part-1-Rasterizing-single-color-triangles" class="headerlink" title="Part 1: Rasterizing single-color triangles"></a>Part 1: Rasterizing single-color triangles</h3><h4 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>第一部分是光栅化三角形。这貌似是每个图形学入门课程开始必做的一个练习。<br>在开始之前，建议先看一下这篇文章，讲述了<a href="https://cs184.eecs.berkeley.edu/sp19/article/7/images-as-data" target="_blank" rel="noopener">图片如何以数据形式存在于计算机中</a>。<br><br>本题的目标是给定每个像素点，判断是否在三角形之内，如果是则将传入的颜色赋值给该像素点。<br>只需要修改两个函数。<br>（1）<code>SampleBuffer::fill_color</code> in <code>drawrend.h</code></p><p>（2）<code>DrawRend::rasterize_triangle</code> in <code>drawrend.cpp</code> </p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>其中 <code>SampleBuffer::fill_color</code> 函数用来填充一个sub-pixel的颜色，如下所示。<br>解释一下其中的几个变量。</p><ul><li>Intuitively, a sample buffer instance is a pixel,</li><li>or (samples_per_side x samples_per_side) sub-pixels.<br>根据注释一个<code>SampleBuffer</code>代表一个采样区域（一开始是一个pixel）。后面这个采样区域会<br>变成由多个sub-pixel组成。sub_pixels[i][j]表明第i行第j个sub-pixel，对于本题来说<br>i和j一直是0（因为只有一个像素）。这个函数的修改很简单，将sub_pixels数组代表的sub-pixel填充好给定的颜色即可。</li></ul><p>但是要注意PixelColorStorage，其声明如下，这个数组中每个元素表示三通道RGB中一个通道的颜色值，每个元素值大小在0-255。</p><pre><code class="C++">typedef std::vector&lt;unsigned char&gt; PixelColorStorage;</code></pre><p>从其初始化可以看出来，这是一个长度为3的数组，白色就是<em>(255, 255, 255)</em>。</p><pre><code class="c++">PixelColorStorage white = std::vector&lt;unsigned char&gt;(3, 255);</code></pre><p><code>SampleBuffer</code> 还有两个数据成员，即sub_pixels和表示sub-pixel边长的samples_per_side。</p><pre><code class="c++">    std::vector&lt;std::vector&lt;PixelColorStorage&gt; &gt; sub_pixels;        size_t samples_per_side;</code></pre><p>我们要补完的<code>fill_color</code>函数如下。在图片初始化解析的过程中，颜色值被全部而Color中r，g，b三个值都是float并且限制在<code>[0,1]</code>的大小，因此我们需要先乘上255在做一个类型转换。否则图片就会是全黑的。</p><pre><code class="c++">    void SampleBuffer::fill_color(int i, int j, Color c) {      PixelColorStorage &amp;p = sub_pixels[i][j];      if(p.size() != 3)      {        std::cout&lt;&lt;&quot;PixelColorStorage没有初始化！&quot;&lt;&lt;endl;      }      else      {        p[0] = (uint8_t)(c.r * 255);        p[1] = (uint8_t)(c.g * 255);        p[2] = (uint8_t)(c.b * 255);      }    }</code></pre><p>然后就是我们的重头戏了，<code>DrawRend::rasterize_triangle</code> 函数，这个绘制三角形的函数将会贯穿整个project。首先我们来看函数的参数，<em>x0,y0,x1,y1,x2,y2</em>分别是三角形的三个顶点。<em>color</em>则是指定的颜色。每个要显示到屏幕上的三角形都会调用一次这个函数，在该函数中使该三角形内的像素点显示成指定的<em>color</em>。</p><pre><code class="c++">void DrawRend::rasterize_triangle( float x0, float y0,                         float x1, float y1,                         float x2, float y2,                         Color color, Triangle *tri) {</code></pre><p>核心是判断点是否位于三角形之内，我的做法是分别取x坐标和y坐标的最大最小值，形成三角形的外接长方形，然后对于这个长方形内的每个点进行逐步的判断，如果位于三角形之内就赋值相应的颜色，否则什么都不做（默认是白色）。这里是存在很大的优化空间的，但是我由于懒暂时没有做。。。。</p><p>三角形内部判定方程如下，值得注意的是，传入的点是没有默认的顺序的，可能是顺时针也可能是逆时针。<br>由于我们的判定方法是 <strong>每个像素点对应的向量</strong> 与 <strong>每条边的法向量叉乘</strong>，如果全部大于等于零（即sin夹角小于等于90°，此时法向量应该是朝向三角形内部）表示在三角形之内，但实际上换一个顺序（即法向量指向三角形之外）,此时只有当叉乘结果全部小于等于零才是在三角形之内的。</p><p>示意图如下。<br></p><center>    <img src="/img/image_for_explain/show_clockwise.png" srcset="/img/loading.gif" width="700px" align="middle"/></center><br><p>如果没有考虑到顺逆时针的问题，运行出来的结果就会像下图这样。</p><center>    <img src="/img/image_for_explain/basic1.png" srcset="/img/loading.gif" width="700px" align="middle"/></center><br><p>三角形内部判定公式如下<br></p><center>    <img src="/img/image_for_explain/slide_049.jpg" srcset="/img/loading.gif" width="700px" align="center"/></center><center>    <img src="/img/image_for_explain/triangle_equation.jpg" srcset="/img/loading.gif" width="700px" align="center"/></center><br>完整的实现如下。<pre><code class="c++">void DrawRend::rasterize_triangle( float x0, float y0,                         float x1, float y1,                         float x2, float y2,                         Color color, Triangle *tri) {    float xMax = std::max(x0, x1);  xMax = std::max(xMax, x2);  float yMax = std::max(y0, y1);  yMax = std::max(yMax, y2);  float xMin = std::min(x0, x1);  xMin = std::min(xMin, x2);  float yMin = std::min(y0, y1);  yMin = std::min(yMin, y2);  float dx_10 = x1 - x0;  float dx_21 = x2 - x1;  float dx_02 = x0 - x2;  float dy_10 = y1 - y0;  float dy_21 = y2 - y1;  float dy_02 = y0 - y2;  for (int x = (int)xMin; x &lt; (int)xMax; x++)  {      for (int y = (int)yMin; y &lt; (int)yMax; y++)      {          float xCenter = x + 0.5f;          float yCenter = y + 0.5f;          int isInside = 0;          if (-dy_10 * (xCenter - x0) + dx_10 * (yCenter - y0) &gt;= 0)              isInside++;          if (-dy_21 * (xCenter - x1) + dx_21 * (yCenter - y1) &gt;= 0)              isInside++;          if (-dy_02 * (xCenter - x2) + dx_02 * (yCenter - y2) &gt;= 0)              isInside++;          if (isInside == 0 || isInside == 3)          {              int xInt = x;              int yInt = y;              if (yInt &gt;= 0 &amp;&amp; yInt &lt; samplebuffer.size() &amp;&amp; xInt &gt;= 0 &amp;&amp; xInt &lt; samplebuffer[yInt].size())                  samplebuffer[yInt][xInt].fill_pixel(color);          }      }  }}</code></pre><p>编译之后在<code>cmake-build-debug</code>文件下于命令行输入<code>./draw ../svg/basic</code> 就可以看到结果。<br>如果看到下图这样的结果那么就恭喜你，第一题完成啦！<br></p><div align="center"><img src="/img/image_for_explain/basic0.png" srcset="/img/loading.gif" height="300px" alt="basic test1" ><img src="/img/image_for_explain/basic2.png" srcset="/img/loading.gif" height="300px" alt="basic test7" ></div><br>### Part 2: Antialiasing triangles#### 题目介绍第二部分让我们实现反走样（antialiasing），至于走样为什么会产生，由于没有学过信号处理对于这部分比较模糊，我只知道大概是由于临近像素点颜色差比较大的地方体现出来就是高频的部分，而如果图像的频率高于奈奎斯特频率（也就是采样频率的一半），就会出现图形彼此交叠失真的现象，下图展示了走样（混叠）和采用反走样后的图片。<br><div align="center"><img src="/img/image_for_explain/aliasing.jpg" srcset="/img/loading.gif" height="330px" alt="走样" ><img src="/img/image_for_explain/antialiasing.jpg" srcset="/img/loading.gif" height="330px" alt="反走样" ></div><br>具体的理论我也不清楚，可以参考下[知乎上更详尽的一种解释](https://zhuanlan.zhihu.com/p/28800047)。<br>回到我们的题目上来，我们要实现反走样，最最基本的方法就是super-sampling，字义上来看是超采样，wiki上翻译成反锯齿，如上图所示也很直观。就是我们将采样点增大，比方说一个像素分成四个子像素sub-pixel，然后对每个子像素采样，最后取一个平均值赋值给该像素。这样整个图形就会变得柔和一些，锯齿会减少。<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>本题中我们将每个像素分成<code>samples_per_side * samples_per_side</code>个子像素，其中<code>samples_per_side</code>就是边长。</p><center>    <img src="/img/image_for_explain/super_sampling.jpg" srcset="/img/loading.gif" height="450px" alt="反走样"></center><br>需要修改以下两个函数（1）`DrawRend::rasterize_triangle` <br>（2）`SampleBuffer::get_pixel_color` in `drawrend.h` <br><p>其中<code>get_pixel_color</code>返回一个像素的平均颜色。代码如下</p><pre><code class="c++">    Color get_pixel_color()     {      if(samples_per_side == 1)      {          return Color(sub_pixels[0][0].data());      }      Color arrangeColor = Color();      for(int i = 0; i &lt; samples_per_side; i++)      {        for(int j = 0; j &lt; samples_per_side; j++)        {            try            {                PixelColorStorage &amp;p = sub_pixels[i][j];                arrangeColor += Color((float)p[0] / 255, (float)p[1] / 255, (float)p[2] / 255);            }            catch (int x)            {                std::cout&lt;&lt;&quot;sub_pixels的长度与samples_per_side不相等！&quot;&lt;&lt;std::endl;            }        }      }      arrangeColor.r /= samples_per_side * samples_per_side;      arrangeColor.g /= samples_per_side * samples_per_side;      arrangeColor.b /= samples_per_side * samples_per_side;      return arrangeColor;    }</code></pre><br>而在渲染三角形的`DrawRend::rasterize_triangle`函数中，我们同样需要做一些修改。核心就是我添加了两个循环，遍历像素内的每个子像素，对子像素进行三角形内部判定，然后调用`fill_color`函数填充每个子像素sub-pixel的颜色而不是像上一题那样直接调用`fill_pixel`填充满整个像素。你可能会问，那我们刚才实现的`get_pixel_color`用来干嘛呢？请参照project文档说明，里面说`get_pixel_color`会在绘制完之后统一调用，给每个像素取平均色。<pre><code class="c++">void DrawRend::rasterize_triangle( float x0, float y0,                         float x1, float y1,                         float x2, float y2,                         Color color, Triangle *tri) {  float xMax = std::max(x0, x1);  xMax = std::max(xMax, x2);  float yMax = std::max(y0, y1);  yMax = std::max(yMax, y2);  float xMin = std::min(x0, x1);  xMin = std::min(xMin, x2);  float yMin = std::min(y0, y1);  yMin = std::min(yMin, y2);  float dx_10 = x1 - x0;  float dx_21 = x2 - x1;  float dx_02 = x0 - x2;  float dy_10 = y1 - y0;  float dy_21 = y2 - y1;  float dy_02 = y0 - y2;  for (int x = (int)xMin; x &lt;= (int)xMax; x++)  {      for (int y = (int)yMin; y &lt;= (int)yMax; y++)      {          if (y &lt; 0 || y &gt;= samplebuffer.size() || x &lt; 0 || x &gt;= samplebuffer[y].size())              continue;          const SampleBuffer &amp;p = samplebuffer[y][x];          for(int sub_x = 0; sub_x &lt; p.samples_per_side; sub_x++)          {            for(int sub_y = 0; sub_y &lt; p.samples_per_side; sub_y++)            {              float centerLength = (1.0f / p.samples_per_side);              float xCenter = x + centerLength * (sub_x + 1) - centerLength / 2;              float yCenter = y + centerLength * (sub_y + 1) - centerLength / 2;              int isInside = 0;              if (-dy_10 * (xCenter - x0) + dx_10 * (yCenter - y0) &gt;= 0)                isInside++;              if (-dy_21 * (xCenter - x1) + dx_21 * (yCenter - y1) &gt;= 0)                isInside++;              if (-dy_02 * (xCenter - x2) + dx_02 * (yCenter - y2) &gt;= 0)                isInside++;              if (isInside == 0 || isInside == 3) {                samplebuffer[y][x].fill_color(sub_x, sub_y, color);              }            }          }      }  }}</code></pre><br>运行后结果如下，可以看到随着采样率的提升，锯齿逐渐减弱。<br><center>    <img src="/img/image_for_explain/part2_all.png" srcset="/img/loading.gif" height="450px" alt="反走样0"></center><br><center>    <img src="/img/image_for_explain/part2_1.png" srcset="/img/loading.gif" height="230px" alt="反走样1">    <img src="/img/image_for_explain/part2_4.png" srcset="/img/loading.gif" height="230px" alt="反走样2">    <img src="/img/image_for_explain/part2_16.png" srcset="/img/loading.gif" height="230px" alt="反走样3"></center><br><h3 id="Part-3-Transforms"><a href="#Part-3-Transforms" class="headerlink" title="Part 3: Transforms"></a>Part 3: Transforms</h3><h4 id="题目介绍-1"><a href="#题目介绍-1" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>第三部分是关于矩阵变换的，这个部分比较简单，只要写好三个变换矩阵就OK了，分别是缩放矩阵，平移矩阵和旋转矩阵。具体的公式证明和讲解请参照<a href="https://cs184.eecs.berkeley.edu/sp18/lecture/transforms-1" target="_blank" rel="noopener">这个PPT</a>和<a href="https://cs184.eecs.berkeley.edu/sp18/lecture/transforms-2" target="_blank" rel="noopener">这个PPT</a>。</p><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p>只需要修改<code>transform.cpp</code>下的三个函数。<br><br>（1）<code>translate</code><br><br>（2）<code>scale</code><br><br>（3）<code>rotate</code><br></p><pre><code class="c++">Matrix3x3 translate(float dx, float dy) {    return Matrix3x3(1, 0, dx,                     0, 1, dy,                     0, 0, 1);}Matrix3x3 scale(float sx, float sy) {    return Matrix3x3(sx, 0, 0,                     0, sy, 0,                     0, 0, 1);}Matrix3x3 rotate(float deg) {    float pi = 3.141592;    float rad = (deg / 180) * pi;    return Matrix3x3(cos(rad), -sin(rad), 0,                     sin(rad), cos(rad), 0,                     0 ,0, 1);}</code></pre><br>运行后结果如下<br><br><center>    <img src="/img/image_for_explain/part3.png" srcset="/img/loading.gif" height="450px"></center><br><h2 id="Section-II-Sampling"><a href="#Section-II-Sampling" class="headerlink" title="Section II: Sampling"></a>Section II: Sampling</h2><h3 id="Part-4-Barycentric-coordinates"><a href="#Part-4-Barycentric-coordinates" class="headerlink" title="Part 4: Barycentric coordinates"></a>Part 4: Barycentric coordinates</h3><h4 id="题目介绍-2"><a href="#题目介绍-2" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>随后我们来到了第二个Section采样。Part4是重心坐标，让我们先来看一下什么是重心坐标，简短的说在我们的例子中，给定三角形的三个坐标A，B，C和对应的Color，然后对于三角形内一点P，我们可以确定三个系数，α，β，γ满足<code>α+β+γ = 1</code>，<code>α*A + β*B + γ*C</code> 就是点P的重心坐标。当然重心坐标没什么用，对我们来说将坐标替换成三个顶点对应的颜色，那么我们就得到了点P在三角形内的颜色插值结果。也就是说我们的根本目的是利用重心坐标系数获取三角形内一点P的插值颜色<br><br>至于如何获取α，β，γ这三个系数，使用如下所示的公式，本质上三个系数之比就是三个顶点与P组成的三个三角形面积之比。（注：以α为例，分子是将点P带入直线方程BC，分母是将点A带入直线方程BC，实际上α就是△BPC和△ABC面积之比）<br></p><center>    <img src="/img/image_for_explain/barycentric1.jpg" srcset="/img/loading.gif" height="330">    <img src="/img/image_for_explain/barycentric2.jpg" srcset="/img/loading.gif" height="330"></center><h4 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h4><p>在本题需修改如下两个函数<br><br>（1）<code>DrawRend::rasterize_triangle</code><br><br>（2）<code>ColorTri::color</code> in <code>svg.cpp</code><br><br>除了我们的老朋友<code>DrawRend::rasterize_triangle</code>以外，还需要完成<code>ColorTri::color</code>以获取我们的插值颜色。如果你一路做到这里，你一定会注意到在三角形渲染函数中，<code>Triangle</code>类型的参数<code>*tri</code>一直没有用到，直到这个部分才开始用到。查看<code>Triangle</code>中的声明我们可以看到。</p><pre><code class="c++">struct Triangle : SVGElement {  Triangle(): SVGElement (TRIANGLE ) { }  Vector2D p0_svg, p1_svg, p2_svg;  void draw(DrawRend *dr, Matrix3x3 global_transform);  virtual Color color(Vector3D p_bary, Vector3D p_dx_bary = Vector3D(), Vector3D p_dy_bary = Vector3D(),                         SampleParams sp = SampleParams()) = 0;};</code></pre><p>包含了三角形的三个顶点（注意这三个顶点没有经过全局变换，所以不能用！）<br>而我们将修改的另外一个函数<code>ColorTri::color</code>则来自于继承自<code>Triangle</code>的<code>ColorTri</code>。<br>在<code>ColorTri</code>中我们可以直接使用三个顶点的颜色<br></p><pre><code class="c++">struct ColorTri : Triangle {   Color color(Vector3D p_bary, Vector3D p_dx_bary = Vector3D(), Vector3D p_dy_bary = Vector3D(),                         SampleParams sp = SampleParams());  Color p0_col, p1_col, p2_col;};</code></pre><br>因此`ColorTri::color`函数的实现如下，将存有三个重心坐标系数的`p_bary`与三个顶点的颜色分别相乘<pre><code class="c++">Color ColorTri::color(Vector3D p_bary, Vector3D p_dx_bary, Vector3D p_dy_bary, SampleParams sp) {    return Color(p_bary[0] * p0_col + p_bary[1] * p1_col + p_bary[2] * p2_col);}</code></pre><br>为了计算重心坐标系数，我在`drawrend.cpp`里添加了两个函数<br><pre><code class="c++">float LineEquation(float x, float y, float x1, float y1, float x2, float y2){    return (-(x - x1) * (y2 - y1) + (y - y1) * (x2 - x1));}bool DrawRend::bary_coord(float x, float y, float x0, float y0, float x1, float y1, float x2, float y2, float* params){    float alpha, beta, gamma;    alpha = params[0] = LineEquation(x, y, x1, y1, x2, y2) / LineEquation(x0, y0, x1, y1, x2, y2);    beta = params[1] = LineEquation(x, y, x2, y2, x0, y0) / LineEquation(x1, y1, x2, y2, x0, y0);    gamma = params[2] = 1 - params[0] - params[1];    return true;}</code></pre><p>之后修改我们的老朋友，如果tri非空就计算获得重心坐标系数然后调用<code>ColorTri::color</code>函数获取颜色，之后就和之前一样了。</p><pre><code class="c++">void DrawRend::rasterize_triangle( float x0, float y0,                         float x1, float y1,                         float x2, float y2,                         Color color, Triangle *tri) {  float xMax = std::max(x0, x1);  xMax = std::max(xMax, x2);  float yMax = std::max(y0, y1);  yMax = std::max(yMax, y2);  float xMin = std::min(x0, x1);  xMin = std::min(xMin, x2);  float yMin = std::min(y0, y1);  yMin = std::min(yMin, y2);  float dx_10 = x1 - x0;  float dx_21 = x2 - x1;  float dx_02 = x0 - x2;  float dy_10 = y1 - y0;  float dy_21 = y2 - y1;  float dy_02 = y0 - y2;  // add for part4  bool isBary = false;  if(tri != nullptr)      isBary = true;  for (int x = (int)xMin; x &lt;= (int)xMax; x++)  {      for (int y = (int)yMin; y &lt;= (int)yMax; y++)      {          if (y &lt; 0 || y &gt;= samplebuffer.size() || x &lt; 0 || x &gt;= samplebuffer[y].size())              continue;                    const SampleBuffer &amp;p = samplebuffer[y][x];          for(int sub_x = 0; sub_x &lt; p.samples_per_side; sub_x++)          {            for(int sub_y = 0; sub_y &lt; p.samples_per_side; sub_y++)            {              float centerLength = (1.0f / p.samples_per_side);              float xCenter = x + centerLength * (sub_x + 1) - centerLength / 2;              float yCenter = y + centerLength * (sub_y + 1) - centerLength / 2;              int isInside = 0;              if (-dy_10 * (xCenter - x0) + dx_10 * (yCenter - y0) &gt;= 0)                isInside++;              if (-dy_21 * (xCenter - x1) + dx_21 * (yCenter - y1) &gt;= 0)                isInside++;              if (-dy_02 * (xCenter - x2) + dx_02 * (yCenter - y2) &gt;= 0)                isInside++;              if (isInside == 0 || isInside == 3) {                  if(!isBary)                      samplebuffer[y][x].fill_color(sub_x, sub_y, color);                  else                  {                      float params[3] = {1, 1, 1};                      if(!this-&gt;bary_coord(x, y, x0, y0, x1, y1, x2, y2, params))                      {                        samplebuffer[y][x].fill_color(sub_x, sub_y, color);                        return;                      }                      Vector3D v3(params[0], params[1], params[2]);                      Color cc = tri-&gt;color(v3);                      samplebuffer[y][x].fill_color(sub_x, sub_y, cc);                  }              }            }          }      }  }}</code></pre><br><p>运行之后，test7就可以正常显示了，结果如下<br></p><center>    <img src="/img/image_for_explain/part4_test7.png" srcset="/img/loading.gif" height="450px"></center><br><h3 id="Part-5-“Pixel-sampling”-for-texture-mapping"><a href="#Part-5-“Pixel-sampling”-for-texture-mapping" class="headerlink" title="Part 5: “Pixel sampling” for texture mapping"></a>Part 5: “Pixel sampling” for texture mapping</h3><h4 id="题目介绍-3"><a href="#题目介绍-3" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>到Part5我们正式进入纹理映射的内容。这一题中我们将通过实现数据结构<code>TexTri</code>和<code>Texture</code>相关的函数实现texture mapping（纹理映射）。纹理映射说来就是一个映射过程，对于surface上的每个像素点找到对应纹理的纹素点。通俗的讲，纹理是一张2D的图片，而surface表面可能是3D的也可能是2D的，纹理映射的过程就是将纹理图包裹到这个表面上。</p><center>    <img src="/img/image_for_explain/Texture_Mapping.jpg" srcset="/img/loading.gif" height="450px"></center><br><h4 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h4><p>我们需要修改的函数如下。<br><br>（1）<code>DrawRend::rasterize_triangle</code><br><br>（2）<code>TexTri::color</code><br><br>（3）<code>Texture::sample</code><br><br>（4）<code>Texture::sample_nearest</code><br><br>（5）<code>Texture::sample_bilinear</code><br><br>首先在<code>DrawRend::rasterize_triangle</code>中创建一个<code>SampleParams</code>，将<code>drawrend</code>类的成员变量<code>psm</code>和<code>lsm</code>赋值给<code>SampleParams</code>中对应成员。与上一题一样，我们一样计算了重心坐标系数然后接着我们调用<code>tri-&gt;color</code>函数，我们通过重心坐标系数计算像素点对应的纹理坐标。</p><pre><code class="c++">Color TexTri::color(Vector3D p_bary, Vector3D p_dx_bary, Vector3D p_dy_bary, SampleParams sp) {  Vector2D tex_point = p_bary[0] * p0_uv + p_bary[1] * p1_uv + p_bary[2] * p2_uv;  sp.p_uv = tex_point;    return tex-&gt;sample(sp);}</code></pre><br><p>随后调用sample函数进行纹理采样。其中levelD我们暂时不用管默认设置为0就行。<br></p><pre><code class="c++">Color Texture::sample(const SampleParams &amp;sp) {    float levelD = 0;    if (sp.psm == P_NEAREST)    {      return this-&gt;sample_nearest(sp.p_uv, (int)levelD);    }    else    {      return this-&gt;sample_bilinear(sp.p_uv, (int)levelD);    }    return Color();}</code></pre><br>接着我们根据指定的psm也就是pixel sample method像素采样方法调用对应函数。下面介绍一下两种采样方法，最邻近采样和双线性采样。最邻近采样很直接，由于uv.x和uv.y是属于`[0,1]`的，因此乘上纹理贴图的长和宽之后才是真正的纹理坐标，但是得到的数可能不是整数，因此我们直接转型后返回该纹理坐标对应的颜色即可。<br><pre><code class="c++">Color Texture::sample_nearest(Vector2D uv, int level) {      if (level &gt;= mipmap.size() || level &lt; 0)      {          std::cout &lt;&lt; &quot;level越界了！ 此时的level大小是:&quot; &lt;&lt;level&lt;&lt;&quot; 坐标是:&quot;&lt;&lt;uv&lt;&lt;std::endl;          return Color();      }      int tx = static_cast&lt;int&gt;(uv.x * mipmap[level].width);      int ty = static_cast&lt;int&gt;(uv.y * mipmap[level].height);      return mipmap[level].get_texel(tx, ty);}</code></pre><br>双线性采样则略显复杂，实际上就是连续采样两次，分别在X方向和Y方向上。对采样点四周的四个点进行两两线性插值得到结果。下图中的t和s是比例，其中`t = (y - u00.y) / (u01.y - u00.y)`，`s = (x - u00.x) / (u10.x - u00.x))`。<br><center>    <img src="/img/image_for_explain/bilinear.png" srcset="/img/loading.gif" height="450px"></center><br>代码如下所示。<pre><code class="c++">Color Texture::sample_bilinear(Vector2D uv, int level) {            if (level &gt;= mipmap.size() || level &lt; 0)      {          std::cout &lt;&lt; &quot;level越界了！ 此时的level大小是:&quot; &lt;&lt;level&lt;&lt;&quot; 坐标是:&quot;&lt;&lt;uv&lt;&lt;std::endl;          return Color();      }      float tx = static_cast&lt;float&gt;(uv.x * mipmap[level].width);      float ty = static_cast&lt;float&gt;(uv.y * mipmap[level].height);      int x0 = static_cast&lt;int&gt;(floor(tx));         int y0 = static_cast&lt;int&gt;(floor(ty));      int x1 = static_cast&lt;int&gt;(ceil(tx));          int y1 = static_cast&lt;int&gt;(ceil(ty));      Color u00 = mipmap[level].get_texel(x0, y0);      Color u10 = mipmap[level].get_texel(x1, y0);      Color u01 = mipmap[level].get_texel(x0, y1);      Color u11 = mipmap[level].get_texel(x1, y1);      Color u0;      Color u1;      if (x1 == x0)      {        u0 = u00;        u1 = u01;      }      else      {        u0 = Lerp((tx - x0) / (x1 - x0), u00, u10);        u1 = Lerp((tx - x0) / (x1 - x0), u01, u11);      }  return Lerp(ty - y0, u0, u1);}Color Texture::Lerp(float x, CGL::Color c0, CGL::Color c1){    return Color(std::max&lt;float&gt;(c0.r + x * (c1.r - c0.r), 0.0),                 std::max&lt;float&gt;(c0.g + x * (c1.g - c0.g), 0.0),                 std::max&lt;float&gt;(c0.b + x * (c1.b - c0.b), 0.0));}</code></pre><p><br></br><br>在命令行下输入<code>./draw ../svg/texmap</code>，运行结果如下<br></br></p><center>    <img src="/img/image_for_explain/part5_1.png" srcset="/img/loading.gif" width="230px">    <img src="/img/image_for_explain/part5_2.png" srcset="/img/loading.gif" width="230px">    <img src="/img/image_for_explain/part5_3.png" srcset="/img/loading.gif" width="230px"></center><br><h3 id="Part-6-“Level-sampling”-with-mipmaps-for-texture-mapping"><a href="#Part-6-“Level-sampling”-with-mipmaps-for-texture-mapping" class="headerlink" title="Part 6: “Level sampling” with mipmaps for texture mapping"></a>Part 6: “Level sampling” with mipmaps for texture mapping</h3><h4 id="题目介绍-4"><a href="#题目介绍-4" class="headerlink" title="题目介绍"></a>题目介绍</h4><p>在上一题的基础上我们在加入level sampling，这里就需要提及一下mipmap技术了。这种技术是将纹理图片分成以一系列，比方说原纹理图是128x128的，那么我就要64*64，32x32，16x16…1x1一共7张图片。这么多图片用来干嘛呢？是为了加快渲染速度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件,这样的贴图被称为 MIP map 或者 mipmap，多级渐进纹理由一组分辨率逐渐降低的纹理序列组成，每一级纹理宽度和高度都是上一级纹理宽度和高度的一半。宽和高不一定相等，也就是说，这些纹理不一定都是正方形。<br><br>这里我转载一段别的博主的话关于mipmap的解释:<br></p><blockquote><p>图形学中经常会用到z值来控制物体的远近，有时会在一个多边形中用z值变化来生成纵深感很强的物体，这时在一个多边形内部的纹理贴图就会用到不同的缩小比率，如果只用原始的纹理去采样，就会在缩小比率大的地方（通常是z值大的地方）出现混叠。1983年，Lance willians在他的论文“Pyramidal Parametrics”中提出了一种解决上述问题的方法。他将原始纹理逐步做下采样（即图像缩小），从而生成一系列的不同大小的纹理，这些纹理被称为mipmap，使用时按照缩小比率来选择合适大小的纹理。比如，我们要用做贴图的纹理大小为 64x32，对它做下采样生成32x16，16x8，8x4，4x2，2x1，1x1的纹理，如果要render的区域大小为14x6，那么我们要么选16x8的纹理贴，要么选16x8与8x4的两块纹理做完线形平均的结果贴。</p></blockquote><p>作者：feixuedudiao<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/feixuedudiao/article/details/6233662" target="_blank" rel="noopener">https://blog.csdn.net/feixuedudiao/article/details/6233662</a><br><br><br>因此简单的说就是为了防止aliasing出现采用的一种新的采样技术。</p><center>    <img src="/img/image_for_explain/mipmap1.jpg" srcset="/img/loading.gif" height = "330px">    <img src="/img/image_for_explain/mipmap2.jpg" srcset="/img/loading.gif" height = "330px"></center>本题要求我们采用mipmap，由于事先纹理已经被处理好了，我们要做的只是选择合适的level。也就是对于一个像素点，原先我们就在纹理原图上取一个纹素（纹理的最小单位）就好了，但现在我们可能一个像素对应多个纹素（也就是选择了分辨率较低的纹理贴图）。<br><h4 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h4><p>还记得上题中填充的lsm属性么，这个就是指定mipmap的level选择方式的。mipmap有两种选择方式，分别是nearest最邻近方法（又是你。。。）和linear线性插值法。最邻近方法就是我得到了一个level，比方说是1.2，由于level都是整数，因此我选择1，表明选择了原纹理贴图一半分辨率的纹理贴图，一个像素对应两个纹素。而linear插值方法则是获取像素在level = 1和level = 2的两个纹理贴图对应的纹理颜色之后再进行一次线性插值，如果此时我们选择的采样方式是双线性插值，那么实际上我们就进行了三次线性插值，这种方式也被称作三线性插值。<br></p><center>    <img src="/img/image_for_explain/part6_1.png" srcset="/img/loading.gif" height="450px"></center>然后获取level的计算方法如下图所示，具体的原理暂时不列举出来了，感兴趣的同学可以直接google mipmap。其中L表示一个像素对应几个纹素。<br><center>    <img src="/img/image_for_explain/part6_2.png" srcset="/img/loading.gif" height="450px"></center><br>我们需要在上一题的基础上修改下列函数：</br><p>（1）<code>DrawRend::rasterize_triangle</code> <br><br>（2）<code>TexTri::color</code> <br><br>（3）<code>Texture::sample</code> <br><br>（4）<code>Texture::get_level</code> <br><br>首先修改<code>DrawRend::rasterize_triangle</code><br></p><pre><code class="c++">void DrawRend::rasterize_triangle( float x0, float y0,                         float x1, float y1,                         float x2, float y2,                         Color color, Triangle *tri) {  float xMax = std::max(x0, x1);  xMax = std::max(xMax, x2);  float yMax = std::max(y0, y1);  yMax = std::max(yMax, y2);  float xMin = std::min(x0, x1);  xMin = std::min(xMin, x2);  float yMin = std::min(y0, y1);  yMin = std::min(yMin, y2);  bool isBary = false;  SampleParams sp;  if(tri != nullptr)  {      isBary = true;      sp.lsm = lsm;      sp.psm = psm;     }  for (int x = (int)xMin; x &lt;= (int)xMax; x++)  {      for (int y = (int)yMin; y &lt;= (int)yMax; y++)      {          if (y &lt; 0 || y &gt;= samplebuffer.size() || x &lt; 0 || x &gt;= samplebuffer[y].size())              continue;          const SampleBuffer &amp;p = samplebuffer[y][x];          for(int sub_x = 0; sub_x &lt; p.samples_per_side; sub_x++)          {            for(int sub_y = 0; sub_y &lt; p.samples_per_side; sub_y++)            {              float centerLength = (1.0f / p.samples_per_side);              float xCenter = x + centerLength * (sub_x + 1) - centerLength / 2;              float yCenter = y + centerLength * (sub_y + 1) - centerLength / 2;              if (inside_triangle(xCenter, yCenter, x0, y0, x1, y1, x2, y2))              {                  if(!isBary)                      samplebuffer[y][x].fill_color(sub_x, sub_y, color);                  else                  {                      float params[3] = {1, 1, 1};                      if(!this-&gt;bary_coord(xCenter, yCenter, x0, y0, x1, y1, x2, y2, params))                      {                        samplebuffer[y][x].fill_color(sub_x, sub_y, color);                        return;                      }                      Vector3D v3(params[0], params[1], params[2]);                      float dx_params[3] = {1, 1, 1};                      float dy_params[3] = {1, 1, 1};                      float p_dx = xCenter + 1;                      float p_dy = yCenter + 1;                      if(!inside_triangle(xCenter + 1, yCenter, x0, y0, x1, y1, x2, y2))                          p_dx = xCenter;                      if(!inside_triangle(xCenter, yCenter + 1, x0, y0, x1, y1, x2, y2))                          p_dy = yCenter;                      this-&gt;bary_coord(p_dx, yCenter, x0, y0, x1, y1, x2, y2, dx_params);                      this-&gt;bary_coord(xCenter, p_dy, x0, y0, x1, y1, x2, y2, dy_params);                      Vector3D p_dx_bary(dx_params[0], dx_params[1], dx_params[2]);                      Vector3D p_dy_bary(dy_params[0], dy_params[1], dy_params[2]);                      Color cc = tri-&gt;color(v3, p_dx_bary, p_dy_bary, sp);                      samplebuffer[y][x].fill_color(sub_x, sub_y, cc);                  }              }            }          }      }  }}</code></pre><br><p>接着修改<code>Texture::get_level</code>函数，计算level层级。<br></p><pre><code class="c++">/** * 获取的level是一个float类型的，之后会根据nearest还是linear来 * 得到最终的值 * @param sp * @return */float Texture::get_level(const SampleParams &amp;sp) {  // 这是两个很小的向量（看作是向量微元）  Vector2D dx_uv = sp.p_dx_uv - sp.p_uv;  Vector2D dy_uv = sp.p_dy_uv - sp.p_uv;  //L2是L的平方，而L就是一个pixel在纹理贴图中占据多少个texl  Vector2D dx_uv_2(dx_uv.x * width, dx_uv.y *height);  Vector2D dy_uv_2(dy_uv.x * width, dy_uv.y *height);  float L2 = std::max&lt;float&gt;(dx_uv_2.norm2(), dy_uv_2.norm2());  if(L2 &lt;= 1)    return 0;  float levelD = log2(sqrt(L2));  return levelD;}</code></pre><br><p>再接着，修改我们上一问实现的<code>Texture::sample</code>函数。加入对于level选择方式的判断。<br></p><pre><code class="c++">Color Texture::sample(const SampleParams &amp;sp) {  float levelD = 0;  if(sp.lsm == L_ZERO)  {    if (sp.psm == P_NEAREST)    {      return this-&gt;sample_nearest(sp.p_uv, (int)levelD);    }    else    {      return this-&gt;sample_bilinear(sp.p_uv, (int)levelD);    }  }  else if(sp.lsm == L_NEAREST)  {    levelD = round(get_level(sp));    if (sp.psm == P_NEAREST)    {      return this-&gt;sample_nearest(sp.p_uv, (int)levelD);    }    else    {      return this-&gt;sample_bilinear(sp.p_uv, (int)levelD);    }  }  else  {    levelD = get_level(sp);    if (sp.psm == P_NEAREST)    {      Color c0 = this-&gt;sample_nearest(sp.p_uv, (int)floor(levelD));      Color c1 = this-&gt;sample_nearest(sp.p_uv, (int)ceil(levelD));      float factor;      float level_up = ceil(levelD);      float level_down = floor(levelD);      if(level_up == level_down)        factor = 0;      else        factor = (levelD - level_down) / (level_up - level_down);      Color final_color(c0 + (-factor * c0) + factor * c1);      final_color = Color(std::max&lt;float&gt;(0, final_color.r),                          std::max&lt;float&gt;(0, final_color.g),                          std::max&lt;float&gt;(0, final_color.b));      return final_color;    }    else {      return this-&gt;sample_bilinear(sp.p_uv, levelD);    }  }}</code></pre><br>OK完事了，运行一下结果区别如下.<br>level0下的最邻近采样和双线性采样<br><center class = "half">    <img src="/img/image_for_explain/zero_near.png" srcset="/img/loading.gif" width="200px" align="center" />    <img src="/img/image_for_explain/zero_bilinear.png" srcset="/img/loading.gif" width="200px" align="center"/></center><br>最邻近选择level下的最邻近采样和双线性采样<br><center>    <img src="/img/image_for_explain/near_near.png" srcset="/img/loading.gif" width="200px" align="center"/>    <img src="/img/image_for_explain/near_bilinear.png" srcset="/img/loading.gif" width="200px" align="center"/></center><br>线性插值选择level下的最邻近采样和双线性采样<br><center>    <img src="/img/image_for_explain/linear_near.png" srcset="/img/loading.gif" width="200px" align="center"/>    <img src="/img/image_for_explain/linear_bilinear.png" srcset="/img/loading.gif" width="200px" align="center"/></center><br>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>计算机课程</tag>
      
      <tag>项目总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019年的展望</title>
    <link href="undefined2019/01/01/new2019/"/>
    <url>2019/01/01/new2019/</url>
    
    <content type="html"><![CDATA[<h2 id="新年展望"><a href="#新年展望" class="headerlink" title="新年展望"></a>新年展望</h2><p>2019年的第一天，写一写对于新的一年的期望。距离我从伯克利(UC Berkeley)回到杭州已经过去了一个礼拜。<br><br>接下来一月中下旬，面临两场考试，分别是软件工程和工程经济这两门水课。软件工程讲道理应该是一门挺融汇贯通的课程，奈何我们代码量太少，老师教的也不太行，就变成了比较水的课。对于我来说，应付应付考试就好啦。工程经济就更水了，都不想提。<br><br>明天会去一家小公司面试游戏客户端的开发，希望能够成功。如果成功了，接下来的时间里就可以好好的做游戏开发，学学unity引擎的使用，了解了解游戏公司的开发流程。同时自己也尝试做自己的小游戏demo。<br><br>说完了流水账的话，回到正题，来说说自己新的一年的展望和计划。<br></p><h3 id="关于技术和理论知识"><a href="#关于技术和理论知识" class="headerlink" title="关于技术和理论知识"></a>关于技术和理论知识</h3><p>（1）首先，是学习游戏开发，尤其是客户端这一块，对于unity引擎的使用，做几个自己的小demo，结合几本书。看《游戏编程模式》学学游戏开发中的设计模式。<br><br>（2）把算法捡起来，用C#刷leetcode的题目，目标是在暑假再次找实习前做完300到400到题目，并且要做好个人的总结。<br><br>（3）恶补数学，主要是为自己学图形学做准备。打算看完MIT的线性代数视频，并且做一些笔记和习题。参考是书就是那位老教授编写的教材，顺便练习下英文的名词。然后是看情况重学微积分，对照着普林斯顿那本微积分。<br><br>（4）学习CS184，伯克利的图形学课程。之前在伯克利的时候把视频资料拷贝下来了，结合piazza讨论区以及各种lecture note还有编程练习，希望可以较为顺利的把图形学课程啃下来。做到对于图形学基本概念有了解，实现一些常用的算法。同时完成一个软光栅和光追渲染器。</p><h3 id="关于个人留学规划"><a href="#关于个人留学规划" class="headerlink" title="关于个人留学规划"></a>关于个人留学规划</h3><p>（1）托福考试，打算寒假结束的时候重新考一次托福。从1月23号考完试开始复习，到寒假结束前2月24号左右考一次，争取考上100！<br><br>（2）GRE考试，GRE考试打算在暑假开始前考掉。<br><br>（3）详细的留学规划，放在下学期。总之美帝有哪个CS方面top50的学校愿意收留我就行。</p><h3 id="关于健身锻炼和读书"><a href="#关于健身锻炼和读书" class="headerlink" title="关于健身锻炼和读书"></a>关于健身锻炼和读书</h3><p>（1）天气回暖后重新开始跑步锻炼。从每晚2公里到5公里，希望在下学期中能够恢复到一口气七八公里。<br><br>（2）如果有空的话，希望能够读一些书，不限类型，感兴趣的就行。</p><hr><p>写到这里，很潦草，不过这也只是一个初步的展望，希望2019能够更上一层楼，加油！</p>]]></content>
    
    
    <categories>
      
      <category>计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>